# Direct Drawing Generator ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆæ›¸
# 1-1. Direct Drawing Generator

- id: saas-direct-drawing
  category: 3
  category_name: ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¨ãƒ‡ã‚£ã‚¿
  title: 3-4 Direct Drawing Generator
  content: ""
  custom_html: |
    <div style="margin-bottom: 20px;">
      <button onclick="window.location.hash=''; location.reload();" style="padding: 8px 16px; background: #4a4a4a; border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 14px;">
        â† SaaSä¸€è¦§ã«æˆ»ã‚‹
      </button>
    </div>

    <!-- MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ -->
    <script src="/js/mcp-client.js?v=post-only"></script>
    <script src="/js/gallery-manager.js?v=0.1.0"></script>
        <style>
        .direct-drawing-interface {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 0;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .app-container {
            display: flex;
            height: clamp(780px, 92vh, 1600px); /* å…¨ä½“é«˜ã•ã‚’æ‹¡å¼µ */
            background: #1a1a1a;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden; /* å…¨ä½“ã®æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯æŠ‘åˆ¶ */
        }

        /* Left Sidebar - Reference Gallery & MCP Config */
        .reference-panel {
            width: 320px;
            background: #2d2d2d;
            padding: 0;
            overflow-y: auto;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        /* ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ */
        .panel-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #3a3a3a;
            position: sticky; /* ãƒ¢ãƒã‚¤ãƒ«ã§å¸¸ã«ä¸Šã«è¡¨ç¤º */
            top: 0;
            z-index: 2; /* ä¸Šä½ã«é…ç½®ã—ã¦ä»–è¦ç´ ã®è¢«ã‚Šã‚’é˜²æ­¢ */
        }

        .panel-tab {
            flex: 1;
            padding: 12px 16px;
            background: #1a1a1a;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .panel-tab.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
            background: #2d2d2d;
        }

        .panel-tab:hover {
            color: #ccc;
            background: #333;
        }

        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* MCPè¨­å®šUI */
        .mcp-config {
            margin-bottom: 20px;
        }

        .config-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
        }

        .config-section h4 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 14px;
        }

        .config-input {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .config-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .server-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #333;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .server-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .server-status.connected {
            background: #4CAF50;
        }

        .server-status.error {
            background: #f44336;
        }

        /* ç”»åƒç”ŸæˆUI */
        .generation-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
        }

        .generation-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .prompt-input {
            min-height: 120px; /* ç´„2å€ã«æ‹¡å¼µ */
            resize: vertical;
        }

        .generation-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .generate-btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #4a9eff, #00d4aa);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }

        .generate-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff33;
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* ç”Ÿæˆçµæœè¡¨ç¤º */
        .generation-results {
            margin-top: 20px;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        .result-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .result-item:hover {
            transform: scale(1.05);
        }

        .result-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .result-actions {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 4px;
        }

        .result-action-btn {
            width: 24px;
            height: 24px;
            background: rgba(0,0,0,0.7);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reference-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .reference-title {
            font-size: 22px;
            font-weight: bold;
            margin: 0;
            color: #ffffff;
        }

        .reload-btn {
            background: #3a3a3a;
            border: 1px solid #505050;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: #e0e0e0;
            font-size: 16px;
        }

        .reload-btn:hover {
            background: #4a4a4a;
            border-color: #606060;
        }

        .reload-btn:active {
            transform: scale(0.95);
        }

        .reload-btn.loading .reload-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Context menu styles */
        .context-menu {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            transition: opacity 0.2s;
        }

        .context-menu:hover {
            background: #3a3a3a !important;
        }

        .reference-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 25px;
            max-height: 800px; /* ã‚®ãƒ£ãƒ©ãƒªãƒ¼è¡¨ç¤ºã®ç¸¦å¹…ã‚’æ‹¡å¼µ */
            overflow-y: auto;
        }

        .reference-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            background: #666;
        }

        .reference-item:hover {
            border-color: #4a9eff;
            transform: scale(1.02);
        }

        .reference-item.selected {
            border-color: #4a9eff;
            box-shadow: 0 0 15px rgba(74, 158, 255, 0.3);
        }

        /* é™¤å¤–è¡¨ç¤º */
        .reference-item.excluded::after {
            content: 'EXCLUDED';
            position: absolute;
            top: 6px; left: 6px;
            font-size: 10px;
            padding: 2px 6px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            border-radius: 4px;
        }
        .reference-item.excluded img { filter: grayscale(1) opacity(0.4); }

        .reference-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .reference-item .checkmark {
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: #4a9eff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .reference-item.selected .checkmark {
            opacity: 1;
        }


        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            position: relative;
            overflow-y: auto; /* ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¨±å¯ */
        }

        /* Header */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: #2d2d2d;
            border-bottom: 1px solid #3a3a3a;
            order: 1;
        }

        .header-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .icon-button {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            background: #3a3a3a;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            transition: all 0.2s ease;
        }

        .icon-button:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }
        /* Gallery modal */
        .gallery-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 10000; }
        .gallery-modal.open { display: flex; }
        .gallery-frame { width: min(1200px, 96vw); height: min(800px, 88vh); background: #111; border: 1px solid #333; border-radius: 12px; overflow: hidden; position: relative; }
        .gallery-frame iframe { width: 100%; height: 100%; border: 0; display: block; }
        .gallery-close { position: absolute; top: 8px; right: 8px; background: #2d2d2d; border: 1px solid #444; color: #fff; border-radius: 6px; width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; }

        .notification-badge {
            position: relative;
        }

        .notification-badge::after {
            content: '1';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 16px;
            height: 16px;
            background: #ff4757;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        /* Before/After Comparison */
        .generation-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            order: 3;
        }

        .before-after-comparison {
            display: flex;
            align-items: center;
            gap: 40px;
        }


        .comparison-label {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 15px;
        }

        .comparison-image {
            width: clamp(280px, 32vw, 420px);
            height: auto;
            /* aspect-ratio: 1 / 1; */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .before-item .comparison-image {
            background: #f0f0f0;
        }

        .after-item .comparison-image {
            background: #333;
        }

        .placeholder-sketch {
            color: #666;
            font-size: 16px;
            text-align: center;
        }

        .placeholder-result {
            color: #999;
            font-size: 16px;
            text-align: center;
        }

        .comparison-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: #4a4a4a;
            border-radius: 50%;
        }

        .arrow-large {
            width: 0;
            height: 0;
            border-left: 15px solid #ffffff;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
        }

        /* Drawing and Controls */
        .drawing-controls {
            order: 2; /* ãƒ˜ãƒƒãƒ€ãƒ¼ã®ç›´ä¸‹ã«é…ç½® */
            position: relative;
            right: auto;
            top: auto;
            display: block;
            padding: 12px 20px;
            background: #232323;
            border-bottom: 1px solid #3a3a3a;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 10px;
        }

        .control-btn {
            padding: 8px 12px;
            border-radius: 6px;
            background: #3a3a3a;
            border: none;
            cursor: pointer;
            color: #ffffff;
            font-size: 12px;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-height: 36px;
            width: 100%;
        }

        .control-btn:hover {
            background: #4a4a4a;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: #4a9eff;
            color: #101010;
            font-weight: 600;
        }

        .control-settings {
            margin-top: 14px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            align-items: center;
        }

        .control-setting {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            color: #ccc;
        }

        .control-setting input[type="color"] {
            width: 44px;
            height: 32px;
            padding: 0;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        .control-setting input[type="range"] {
            width: 100%;
        }

        .text-controls {
            margin-top: 12px;
            display: grid;
            gap: 10px;
            grid-template-columns: minmax(0, 1fr) 180px 130px;
            align-items: center;
        }

        .text-controls input[type="text"] {
            padding: 8px 10px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .text-controls input[type="text"]:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .text-size-wrap {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 12px;
            color: #ccc;
        }

        .text-size-wrap input[type="range"] {
            width: 100%;
        }

        .comparison-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        #drawingCanvas {
            display: none;
            border: 2px solid #4a9eff;
            border-radius: 12px;
            width: 100%;
            height: 100%;
            touch-action: none; /* ã‚¹ãƒãƒ›ã§ã®æç”»ã«å¿…è¦ */
        }

        /* ===== ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ ===== */
        @media (max-width: 1200px) {
            .reference-panel { width: 240px; }
            .before-after-comparison { gap: 24px; }
        }

        @media (max-width: 900px) {
            .comparison-image { width: clamp(240px, 42vw, 360px); }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
                min-height: 92vh; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚‚è¡¨ç¤ºé«˜ã‚’ç¢ºä¿ */
            }
            .reference-panel {
                width: 100%;
                max-height: 420px; /* å·¦ãƒ‘ãƒãƒ«ã®ç¸¦å¹…ã‚’æ‹¡å¼µ */
                border-right: none;
                border-bottom: 1px solid #3a3a3a;
                overflow-y: auto;
            }
            .reference-grid {
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
                max-height: 360px; /* ãƒ¢ãƒã‚¤ãƒ«ã®ã‚®ãƒ£ãƒ©ãƒªãƒ¼é«˜ã•ã‚‚æ‹¡å¼µ */
            }
            .before-after-comparison { flex-direction: column; gap: 16px; }
            .comparison-image { width: min(92vw, 420px); }
            .drawing-controls { padding: 10px 12px; }
        .control-buttons { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .text-controls { grid-template-columns: repeat(auto-fit, minmax(0, 1fr)); }
    }

        @media (max-width: 420px) {
            .header-title { font-size: 20px; }
            .icon-button { width: 32px; height: 32px; }
            .control-btn { font-size: 11px; padding: 6px 10px; }
        }
        </style>

    <div class="direct-drawing-interface">
        <div class="app-container">
            <!-- Left Sidebar - Reference Gallery & MCP Config -->
            <div class="reference-panel">
                <!-- ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ -->
                <div class="panel-tabs" role="tablist" aria-label="Direct Drawing Tabs">
                    <button type="button" class="panel-tab active" data-tab="reference" role="tab" aria-selected="true" onclick="switchLeftTab('reference', event)">Media Gallery</button>
                    <button type="button" class="panel-tab" data-tab="mcp-config" role="tab" aria-selected="false" onclick="switchLeftTab('mcp-config', event)">MCPè¨­å®š</button>
                    <button type="button" class="panel-tab" data-tab="generation" role="tab" aria-selected="false" onclick="switchLeftTab('generation', event)">Generate</button>
                </div>

                <!-- ãƒ‘ãƒãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
                <div class="panel-content">
                    <!-- Reference Tab -->
                    <div id="reference-tab" class="tab-content active">
                        <div class="reference-header">
                            <h2 class="reference-title">Media Gallery</h2>
                            <div style="display:flex; gap:8px; align-items:center;">
                              <button class="reload-btn" id="openEmbeddedGallery" title="ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‹ã‚‰é¸æŠ"><span class="reload-icon">ğŸ–¼ï¸</span></button>
                              <button class="reload-btn" onclick="window.open('/#dynamic-media-gallery', '_blank')" title="ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚’æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ã">
                                <span class="reload-icon">ğŸ——</span>
                              </button>
                            </div>
                        </div>
                        <div style="display:flex; gap:6px; align-items:center; margin:8px 0 12px 0; flex-wrap: wrap;">
                          <input id="externalImageUrl" class="config-input" placeholder="å¤–éƒ¨ç”»åƒURLï¼ˆæ”¹è¡Œ/ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§è¤‡æ•°å¯ï¼‰" style="margin:0; min-width:260px;">
                          <button class="control-btn" id="applyExternalImage" style="white-space:nowrap;">Beforeã«é©ç”¨</button>
                          <button class="control-btn" id="addUrlsToReference" style="white-space:nowrap;">URLã‚’å‚ç…§ã¸è¿½åŠ </button>
                          <input type="file" id="externalFiles" accept="image/*" multiple style="display:none;">
                          <button class="control-btn" id="addFilesToReference" style="white-space:nowrap;">ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ </button>
                        </div>
                        <div style="text-align: center; padding: 20px;">
                            <p style="color: #ccc; margin-bottom: 15px;">ãƒ¡ãƒ‡ã‚£ã‚¢ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‹ã‚‰ç”»åƒã‚’é¸æŠ</p>
                            <button onclick="window.open('/#dynamic-media-gallery', '_blank')"
                                    style="padding: 12px 24px; background: linear-gradient(45deg, #4a9eff, #00d4aa); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; text-decoration: none; display: inline-block; transition: transform 0.2s;">
                                ğŸ“‚ Dynamic Media Gallery ã‚’é–‹ã
                            </button>
                        </div>
                        <div class="reference-grid" id="referenceGrid">
                            <!-- Images will be loaded dynamically -->
                        </div>
                        <!-- å…¥åŠ›å¯¾è±¡ãƒˆãƒ¬ã‚¤ -->
                        <div id="inputTargetBar" style="margin-top:12px; border:1px solid #333; border-radius:8px; padding:8px; background:#1e1e1e;">
                          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-bottom:6px;">
                            <strong style="color:#ddd;">Input Targets</strong>
                            <label style="display:flex; align-items:center; gap:6px; color:#bbb;">
                              <input type="checkbox" id="toggleUseAll" checked>
                              å…¨ä»¶æŠ•å…¥ï¼ˆå‚ç…§ã«ã‚ã‚‹å…¨ç”»åƒã‚’ä½¿ç”¨ï¼‰
                            </label>
                            <div style="margin-left:auto; display:flex; gap:6px;">
                              <button class="control-btn" id="registerBeforeToInput" style="white-space:nowrap;" title="Beforeç”»åƒã‚’Input Targetã«è¿½åŠ ">ğŸ¯ Inputç™»éŒ²</button>
                              <button class="control-btn" id="selectAllRef" title="å‚ç…§å†…ã‚’å…¨é¸æŠ">å…¨é¸æŠ</button>
                              <button class="control-btn" id="clearSelectedRef" title="å‚ç…§å†…ã®é¸æŠã‚’è§£é™¤">å…¨è§£é™¤</button>
                              <button class="control-btn" id="resetExclusions" title="é™¤å¤–ã‚’ã™ã¹ã¦è§£é™¤">é™¤å¤–ãƒªã‚»ãƒƒãƒˆ</button>
                            </div>
                          </div>
                          <div id="inputTray" style="display:flex; gap:6px; flex-wrap:wrap; min-height:40px;"></div>
                          <div id="inputTrayInfo" style="color:#9aa; font-size:12px; margin-top:6px;">å¯¾è±¡: 0ä»¶</div>
                        </div>
                    </div>

                    <!-- MCP Config Tab -->
                    <div id="mcp-config-tab" class="tab-content">
                        <div class="mcp-config">
                            <div class="config-section">
                                <h4>æ–°ã—ã„MCPã‚µãƒ¼ãƒãƒ¼ã‚’è¿½åŠ </h4>
                                <input type="text" class="config-input" id="serverName" placeholder="ã‚µãƒ¼ãƒãƒ¼å">
                                <input type="text" class="config-input" id="serverUrl" placeholder="ã‚µãƒ¼ãƒãƒ¼URL">
                                <input type="text" class="config-input" id="serverAuth" placeholder="èªè¨¼ (Bearer token)">
                                <button class="control-btn" id="addServer">ã‚µãƒ¼ãƒãƒ¼è¿½åŠ </button>
                            </div>

                            <div class="config-section">
                                <h4>ç™»éŒ²æ¸ˆã¿ã‚µãƒ¼ãƒãƒ¼</h4>
                                <div id="serverList">
                                    <!-- Servers will be listed here -->
                                </div>
                            </div>

                            <!-- ãƒ‡ãƒãƒƒã‚°ã‚¨ãƒªã‚¢ -->
                            <div class="config-section">
                                <h4>ğŸ› ãƒ‡ãƒãƒƒã‚°æƒ…å ±</h4>
                                <div style="display:flex; gap:6px; margin-bottom:6px; align-items:center;">
                                  <button id="mcpDebugCopy" class="control-btn" style="padding:6px 10px;">ã‚³ãƒ”ãƒ¼</button>
                                  <button id="mcpDebugClear" class="control-btn" style="padding:6px 10px;">ã‚¯ãƒªã‚¢</button>
                                </div>
                                <div id="debugOutput" style="background: #0d1117; color: #c9d1d9; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 11px; max-height: 220px; overflow-y: auto; white-space: pre-wrap; border: 1px solid #333;">
                                    ãƒ‡ãƒãƒƒã‚°æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Generation Tab -->
                    <div id="generation-tab" class="tab-content">
                        <div class="generation-section">
                            <h4>ç”»åƒç·¨é›†</h4>
                            <div class="generation-controls">
                                <textarea class="config-input prompt-input" id="promptInput" placeholder="ç·¨é›†ã—ãŸã„å†…å®¹ï¼ˆä¾‹: è‰²å‘³ã‚’æš–è‰²ã«ã€è‚Œã‚’ãªã‚ã‚‰ã‹ã«ã€èƒŒæ™¯ã‚’å¤•æ™¯ã« ãªã©ï¼‰"></textarea>

                        <button class="generate-btn" id="nanoBtn" style="background: linear-gradient(45deg, #a855f7, #00d4aa);">
                            <span id="nanoBtnText">Nano Banana Edit</span>
                        </button>
                        <button class="generate-btn" id="seedBtn" style="background: linear-gradient(45deg, #4a9eff, #00d4aa);">
                            <span id="seedBtnText">Seedream Edit</span>
                        </button>
                        <details id="nanoDebugBox" style="margin-top:10px;">
                          <summary style="cursor:pointer;color:#ccc;">ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°</summary>
                          <div style="display:flex;gap:6px;margin:6px 0;align-items:center;">
                            <button id="nanoLogCopy" class="control-btn" style="padding:6px 10px;">ã‚³ãƒ”ãƒ¼</button>
                            <button id="nanoLogClear" class="control-btn" style="padding:6px 10px;">ã‚¯ãƒªã‚¢</button>
                            <label style="font-size:12px;color:#aaa;display:flex;gap:6px;align-items:center;">
                              <input type="checkbox" id="nanoLogAutoscroll" checked>
                              ã‚ªãƒ¼ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                            </label>
                          </div>
                          <pre id="nanoDebugLog" style="background:#0c0c0c;border:1px solid #2a2a2a;color:#bdbdbd;padding:10px;border-radius:8px;max-height:440px;overflow:auto;white-space:pre-wrap;word-break:break-word;"></pre>
                        </details>
                    </div>
                </div>

                        <div class="generation-results">
                            <h4>ç”Ÿæˆçµæœ</h4>
                            <div class="result-grid" id="resultGrid">
                                <!-- Generated images will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- Header -->
                <div class="app-header">
                    <h1 class="header-title">AI Generation</h1>
                    <div class="header-controls">
                        <button class="icon-button">ğŸ”</button>
                        <button class="icon-button">ğŸ’¾</button>
                        <button class="icon-button notification-badge">ğŸ›’</button>
                    </div>
                </div>

                <!-- Before/After Comparison Area -->
                <div class="generation-area">
                    <div class="before-after-comparison">
                        <div class="comparison-item before-item">
                            <div class="comparison-label">Before</div>
                            <div class="comparison-image" id="beforeImage">
                                <img src="" alt="Before" crossorigin="anonymous" style="width: 100%; height: 100%; object-fit: contain;">
                                <canvas id="drawingCanvas" width="300" height="300" style="position: absolute; top: 0; left: 0; cursor: crosshair; z-index: 10; display: none; border-radius: 12px;"></canvas>
                            </div>
                        </div>
                        <div class="comparison-arrow">
                            <div class="arrow-large"></div>
                        </div>
                        <div class="comparison-item after-item">
                            <div class="comparison-label">After</div>
                            <div class="comparison-image" id="afterImage"></div>
                        </div>
                    </div>
                </div>

                <!-- Drawing and Controls -->
                <div class="drawing-controls">
                    <div class="control-buttons">
                        <button class="control-btn" id="clearCanvas">ğŸ—‘ï¸ Clear</button>
                        <button class="control-btn" id="switchImages">â‡„ Switch</button>
                        <button class="control-btn" id="toggleDraw">âœï¸ Draw</button>
                        <button class="control-btn" id="toggleEraser">ğŸ§½ Eraser</button>
                        <button class="control-btn" id="saveDrawing">ğŸ’¾ Save</button>
                    </div>
                    <div class="control-settings">
                        <label class="control-setting">
                            <span>ãƒšãƒ³ã‚«ãƒ©ãƒ¼</span>
                            <input type="color" id="penColor" value="#ff0000">
                        </label>
                        <label class="control-setting">
                            <span>ãƒšãƒ³ã‚µã‚¤ã‚º <span id="penSizeLabel">3 px</span></span>
                            <input type="range" id="penSize" min="1" max="50" value="3">
                        </label>
                        <label class="control-setting">
                            <span>æ¶ˆã—ã‚´ãƒ ã‚µã‚¤ã‚º <span id="eraserSizeLabel">40 px</span></span>
                            <input type="range" id="eraserSize" min="8" max="160" value="40">
                        </label>
                    </div>
                    <div class="text-controls">
                        <input type="text" id="textInput" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›...">
                        <div class="text-size-wrap">
                            <span>æ–‡å­—ã‚µã‚¤ã‚º <span id="textSizeLabel">24 px</span></span>
                            <input type="range" id="textSize" min="8" max="128" value="24">
                        </div>
                        <button class="control-btn" id="placeTextBtn">ğŸ…£ ãƒ†ã‚­ã‚¹ãƒˆé…ç½®</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        if (typeof window.switchLeftTab !== 'function') {
            window.switchLeftTab = function(){ console.warn('switchLeftTab not ready yet'); };
        }
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let allImages = []; // Will be populated from JSON file
            const appRoot = document.getElementById('saas-direct-drawing');
            const rootDoc = appRoot || document;
            const cssEscape = (typeof CSS !== 'undefined' && CSS.escape)
              ? CSS.escape.bind(CSS)
              : (value => String(value).replace(/[^a-zA-Z0-9_\-]/g, ch => '\\' + ch));
            const qs = selector => rootDoc.querySelector(selector);
            const qsa = selector => rootDoc.querySelectorAll(selector);
            const byId = id => {
                if (!id) return null;
                if (appRoot) {
                    try {
                        return appRoot.querySelector('#' + cssEscape(id));
                    } catch (_) {
                        return appRoot.querySelector(`[id="${String(id).replace(/"/g, '\\"')}"]`);
                    }
                }
                return document.getElementById(id);
            };

            // ===== MCPæ©Ÿèƒ½ã¨ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ =====
            let mcpConfigManager;
            let currentMcpClient = null;

            // ã‚·ãƒ³ãƒ—ãƒ«ãªJSONãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰
            (function ensureJsonModal(){
                if (window.openJsonModal) return;
                const modal = document.createElement('div');
                modal.id = 'jsonModal';
                modal.style.cssText = 'position:fixed;inset:0;display:none;background:rgba(0,0,0,0.6);z-index:9999;';
                modal.innerHTML = `
                  <div style="max-width:840px;width:94%;margin:5vh auto;background:#1e1e1e;border:1px solid #3a3a3a;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.5);">
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #333;">
                      <div id="jsonModalTitle" style="font-weight:600;color:#fff;font-size:14px;">Debug</div>
                      <div>
                        <button id="jsonCopyBtn" style="margin-right:6px;padding:6px 10px;border:1px solid #3a3a3a;background:#2a2a2a;color:#fff;border-radius:6px;cursor:pointer;">ã‚³ãƒ”ãƒ¼</button>
                        <button id="jsonCloseBtn" style="padding:6px 10px;border:1px solid #3a3a3a;background:#2a2a2a;color:#fff;border-radius:6px;cursor:pointer;">é–‰ã˜ã‚‹</button>
                      </div>
                    </div>
                    <pre id="jsonModalBody" style="margin:0;padding:12px;max-height:90vh;overflow:auto;color:#ddd;white-space:pre-wrap;word-break:break-all;"></pre>
                  </div>`;
                document.body.appendChild(modal);
                const bodyEl = modal.querySelector('#jsonModalBody');
                const titleEl = modal.querySelector('#jsonModalTitle');
                modal.querySelector('#jsonCloseBtn').addEventListener('click', ()=> modal.style.display='none');
                modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none';});
                modal.querySelector('#jsonCopyBtn').addEventListener('click', async ()=>{
                  try { await navigator.clipboard.writeText(bodyEl.textContent||''); alert('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ'); } catch(e){
                    const t = document.createElement('textarea'); t.value = bodyEl.textContent||''; document.body.appendChild(t); t.select(); document.execCommand('copy'); t.remove(); alert('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                  }
                });
                window.openJsonModal = function(text, title){
                  titleEl.textContent = title || 'Debug';
                  bodyEl.textContent = text;
                  modal.style.display = 'block';
                };
            })();

            // æ—¢å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå¿…è¦ã«å¿œã˜ã¦ãƒšãƒ¼ã‚¸ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰ä¸Šæ›¸ãå¯ï¼‰
            if (typeof window.__max_input_images__ === 'undefined') window.__max_input_images__ = 10; // å…¥åŠ›ç”»åƒã®æœ€å¤§æšæ•°
            if (typeof window.__use_all_reference_images__ === 'undefined') window.__use_all_reference_images__ = true; // å‚ç…§ã‚¿ãƒ–ã«è¡¨ç¤ºã•ã‚ŒãŸç”»åƒã‚’å…¨ã¦å…¥åŠ›ã«ä½¿ç”¨
            if (typeof window.__placeholder_size__ === 'undefined') window.__placeholder_size__ = 1024; // ç™½ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã®ä¸€è¾ºpx
            if (typeof window.__default_placeholder_count__ === 'undefined') window.__default_placeholder_count__ = 1; // å¿…è¦ãªã‚‰è¤‡æ•°æš
            if (!window.__input_exclude_set__) window.__input_exclude_set__ = new Set(); // use_allæ™‚ã®é™¤å¤–ãƒªã‚¹ãƒˆ
            if (!window.__input_manual_set__) window.__input_manual_set__ = new Set(); // æ‰‹å‹•ã§è¿½åŠ ã—ãŸå…¥åŠ›å¯¾è±¡

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®Before/Afterã‚’ç™½ä¸€è‰²(1024x1024)ã«åˆæœŸåŒ–
            (function ensureWhitePlaceholders(){
              try {
                function makeWhite(size){
                  size = Number(size)||1024; const c=document.createElement('canvas'); c.width=size; c.height=size; const ctx=c.getContext('2d');
                  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,size,size); return c.toDataURL('image/png');
                }
                const whiteUrl = makeWhite(window.__placeholder_size__);
                const before = byId('beforeImage');
                if (before){
                  before.innerHTML = `<img src="${whiteUrl}" alt="Before (white 1024)" crossorigin="anonymous" style="width: 100%; height: 100%; object-fit: contain;">` + before.innerHTML.replace(/^[\s\S]*?<canvas /,'<canvas ');
                }
                const after = byId('afterImage');
                if (after){ after.innerHTML = `<img src="${whiteUrl}" alt="After (white 1024)" crossorigin="anonymous" style="width: 100%; height: 100%; object-fit: contain;">`; }
              } catch(_){ /* no-op */ }
            })();

            // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆï¼ˆAI Portrait / Direct Drawing å…±é€šï¼‰
            if (!window.__kamuiUnifiedSwitchLeftTab__) {
                window.__kamuiUnifiedSwitchLeftTab__ = true;
                window.switchLeftTab = function(name, ev){
                    try {
                        var root = null;
                        if (ev && ev.target && ev.target.closest) {
                            root = ev.target.closest('#saas-ai-portrait, #saas-direct-drawing, .reference-panel, .ai-portrait-interface, .direct-drawing-interface');
                            if (root && !root.id && root.closest) {
                                root = root.closest('#saas-ai-portrait, #saas-direct-drawing');
                            }
                        }

                        var tabSelector = '#' + name + '-tab';
                        var portraitRoot = document.getElementById('saas-ai-portrait');
                        var directRoot = document.getElementById('saas-direct-drawing');

                        if (!root) {
                            if (directRoot && directRoot.querySelector && directRoot.querySelector(tabSelector)) {
                                root = directRoot;
                            } else if (portraitRoot && portraitRoot.querySelector && portraitRoot.querySelector(tabSelector)) {
                                root = portraitRoot;
                            }
                        }

                        if (!root) {
                            var activeHash = (location.hash || '').split('&')[0];
                            if (activeHash === '#saas-direct-drawing' && directRoot) {
                                root = directRoot;
                            } else if (activeHash === '#saas-ai-portrait' && portraitRoot) {
                                root = portraitRoot;
                            } else {
                                root = portraitRoot || directRoot || document;
                            }
                        }

                        var isDirect = root && root.id === 'saas-direct-drawing';
                        var base = isDirect ? '#saas-direct-drawing' : '#saas-ai-portrait';

                        var tabs = (root && root.querySelectorAll) ? root.querySelectorAll('.panel-tab') : [];
                        for (var i=0;i<tabs.length;i++) {
                            tabs[i].classList.remove('active');
                            tabs[i].setAttribute('aria-selected','false');
                        }

                        var contents = (root && root.querySelectorAll) ? root.querySelectorAll('.tab-content') : [];
                        for (var j=0;j<contents.length;j++) {
                            contents[j].classList.remove('active');
                            contents[j].style.display = 'none';
                        }

                        var btn = (root && root.querySelector) ? root.querySelector('.panel-tab[data-tab="'+name+'"]') : null;
                        if (btn) {
                            btn.classList.add('active');
                            btn.setAttribute('aria-selected','true');
                        }

                        var target = (root && root.querySelector) ? root.querySelector(tabSelector) : null;
                        if (target) {
                            target.classList.add('active');
                            target.style.display = 'block';
                        }

                        var h = String(location.hash||'');
                        var extra = (name && name !== 'reference') ? ('&tab=' + name) : '';
                        if (base && h.startsWith(base)) {
                            var newHash = base + extra;
                            if (h !== newHash) {
                                history.replaceState({ app: isDirect ? 'direct-drawing' : 'ai-portrait', tab: name }, '', newHash);
                            }
                        }
                    } catch(e) {
                        console.warn('switchLeftTab failed', e);
                    }
                };
            }

            // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚‚æ®‹ã™ï¼ˆæ–°è¦/æ—¢å­˜ã©ã¡ã‚‰ã§ã‚‚å‹•ãï¼‰
            (function initTabClicks(){
                var tabs = qsa('.panel-tab');
                for (var i=0;i<tabs.length;i++){
                    tabs[i].addEventListener('click', function(e){
                        e.preventDefault();
                        e.stopPropagation();
                        var targetTab = this.getAttribute('data-tab');
                        if (targetTab) window.switchLeftTab(targetTab, e);
                    }, { passive: false });
                }
            })();

            // å‚ç…§ã‚°ãƒªãƒƒãƒ‰ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 

            function addToReferenceGrid(urls, selectAll = true){

              try {

                const grid = byId('referenceGrid');

                if (!grid) return 0;

                const existing = new Set(Array.from(grid.querySelectorAll('img')).map(img => toAbsoluteUrl((img && img.src) || '')));

                let added = 0;

                urls.forEach((u)=>{

                  if (!u) return;

                  const abs = toAbsoluteUrl(u);

                  if (!abs || existing.has(abs)) return;

                  existing.add(abs);

                  const displaySrc = (/^data:/i.test(u) || /^blob:/i.test(u) || /^https?:\/\//i.test(u)) ? u : abs;

                  const div = document.createElement('div');

                  div.className = 'reference-item' + (selectAll ? ' selected' : '');

                  const alt = 'User image';

                  div.innerHTML = `<img src="${displaySrc}" alt="${alt}"><div class="checkmark">âœ“</div>`;

                  div.addEventListener('click', function(e){

                    e.preventDefault();

                    this.classList.toggle('selected');

                    const img = this.querySelector('img');

                    const beforeImg = qs('#beforeImage img');

                    if (img && beforeImg) { beforeImg.src = img.src; beforeImg.alt = img.alt||'reference'; }

                    this.classList.remove('excluded');

                    const absSel = toAbsoluteUrl((this.querySelector('img')||{}).src||'');

                    if (absSel && window.__input_exclude_set__) window.__input_exclude_set__.delete(absSel);

                    updateInputTray();

                  });

                  div.addEventListener('contextmenu', function(e){ e.preventDefault(); alert((this.querySelector('img')||{}).src||''); });

                  grid.prepend(div);

                  added++;

                });

                if (added) { try { updateInputTray(); } catch(_){ } }

                return added;

              } catch(_) { return 0; }

            }            // å…¥åŠ›å¯¾è±¡UIæ“ä½œ
            (function initInputTrayControls(){
              const useAll = byId('toggleUseAll');
              if (useAll) {
                useAll.addEventListener('change', () => {
                  window.__use_all_reference_images__ = !!useAll.checked;
                  updateInputTray();
                });
              }
              const selectAllBtn = byId('selectAllRef');
              const clearSelBtn = byId('clearSelectedRef');
              const resetEx = byId('resetExclusions');
              const registerBeforeBtn = byId('registerBeforeToInput');
              if (selectAllBtn) selectAllBtn.addEventListener('click', () => {
                qsa('#referenceGrid .reference-item').forEach(el => el.classList.add('selected'));
                updateInputTray();
              });
              if (clearSelBtn) clearSelBtn.addEventListener('click', () => {
                qsa('#referenceGrid .reference-item').forEach(el => el.classList.remove('selected'));
                updateInputTray();
              });
              if (resetEx) resetEx.addEventListener('click', () => {
                if (window.__input_exclude_set__) window.__input_exclude_set__.clear();
                qsa('#referenceGrid .reference-item.excluded').forEach(el => el.classList.remove('excluded'));
                updateInputTray();
              });
              if (registerBeforeBtn) registerBeforeBtn.addEventListener('click', () => {
                try {
                  const beforeImg = qs('#beforeImage img');
                  if (!beforeImg || !beforeImg.src) {
                    alert('Beforeç”»åƒãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                  }
                  const abs = toAbsoluteUrl(beforeImg.src);
                  if (!abs) {
                    alert('Beforeç”»åƒã®URLã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
                    return;
                  }
                  if (!(window.__input_manual_set__ instanceof Set)) {
                    window.__input_manual_set__ = new Set();
                  }
                  if (window.__input_manual_set__.has(abs)) {
                    alert('Beforeç”»åƒã¯æ—¢ã«Input Targetã«ç™»éŒ²æ¸ˆã¿ã§ã™');
                    return;
                  }
                  window.__input_manual_set__.add(abs);
                  updateInputTray();
                  try { nanoLog('ğŸ¯ Input Targetã«Beforeã‚’ç™»éŒ²: ' + abs); } catch(_) {}
                } catch (err) {
                  console.error('registerBeforeToInput failed', err);
                  alert('Input Targetã¸ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (err && err.message ? err.message : err));
                }
              });
            })();

            // å¤–éƒ¨ç”»åƒURLã‚’Before/å‚ç…§ã«åæ˜ 
            (function initExternalUrl(){
              try {
                var btn = byId('applyExternalImage');
                var inp = byId('externalImageUrl');
                var addUrlsBtn = byId('addUrlsToReference');
                var filesBtn = byId('addFilesToReference');
                var filesInput = byId('externalFiles');
                if (!btn || !inp) return;

                function parseUrls(raw){
                  const parts = String(raw||'').split(/[\n,\s]+/).map(s=>s.trim()).filter(Boolean);
                  return parts.filter(u=>/^https?:\/\//i.test(u));
                }
                btn.addEventListener('click', function(){
                  var raw = (inp.value||'').trim();
                  if (!raw) { alert('ç”»åƒURLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
                  const urls = parseUrls(raw);
                  if (!urls.length) { alert('https:// ã‹ã‚‰å§‹ã¾ã‚‹ç”»åƒURLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
                  var url = urls[0];
                  var before = qs('#beforeImage img');
                  if (!before) { alert('Beforeç”»åƒã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
                  before.src = url; before.alt = 'External image';
                  if (urls.length > 1) {
                    addToReferenceGrid(urls.slice(1), true);
                    alert('Beforeã‚’æ›´æ–°ã—ã€æ®‹ã‚Šã‚’å‚ç…§ã¸è¿½åŠ ã—ã¾ã—ãŸ');
                  } else {
                    alert('Beforeç”»åƒã‚’æ›´æ–°ã—ã¾ã—ãŸ');
                  }
                });

                if (addUrlsBtn) {
                  addUrlsBtn.addEventListener('click', function(){
                    const urls = parseUrls(inp.value||'');
                    if (!urls.length) { alert('è¿½åŠ ã™ã‚‹URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
                    const added = addToReferenceGrid(urls, true);
                    alert(added + 'ä»¶ã‚’å‚ç…§ã¸è¿½åŠ ã—ã¾ã—ãŸ');
                  });
                }

                if (filesBtn && filesInput) {
                  filesBtn.addEventListener('click', function(){ filesInput.click(); });
                  filesInput.addEventListener('change', function(){
                    const files = Array.from(filesInput.files||[]).slice(0, (window.__max_input_images__||10));
                    if (!files.length) return;
                    const readers = files.map(f => new Promise((resolve)=>{ const r=new FileReader(); r.onload=()=>resolve(r.result); r.readAsDataURL(f); }));
                    Promise.all(readers).then((urls)=>{
                      const added = addToReferenceGrid(urls, true);
                      alert(added + 'ä»¶ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã¸è¿½åŠ ã—ã¾ã—ãŸ');
                      filesInput.value = '';
                    });
                  });
                }
              } catch(err){ console.warn('external url init failed', err); }
            })();

            // ãƒ˜ãƒ«ãƒ‘ãƒ¼: å®‰å…¨ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¼µã‚‹
            function onById(id, type, handler, opts){
                try {
                    var el = byId(id);
                    if (el && el.addEventListener) { el.addEventListener(type, handler, opts||false); }
                    else { console.warn('[direct-drawing] element not found:', id); }
                } catch(err){ console.warn('[direct-drawing] onById failed', id, err); }
            }

            // MCPè¨­å®šã®ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³/ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
            onById('mcpDebugCopy', 'click', async function(){
                try {
                    var box = byId('debugOutput');
                    var text = (box && (box.textContent || box.innerText)) || '';
                    await navigator.clipboard.writeText(text);
                    this.textContent = 'ã‚³ãƒ”ãƒ¼æ¸ˆã¿';
                    var self = this; setTimeout(function(){ self.textContent = 'ã‚³ãƒ”ãƒ¼'; }, 1500);
                } catch(e) {
                    alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            });
            onById('mcpDebugClear', 'click', function(){
                try {
                    var box = byId('debugOutput');
                    if (box) box.innerHTML = 'ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚';
                } catch(_){}
            });

            // ãƒãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚¿ãƒ–åŒæœŸï¼ˆä¾‹: #saas-direct-drawing&tab=mcp-configï¼‰
            function parseTabFromHash(){
                var h = String(location.hash||'');
                if (!h.startsWith('#saas-direct-drawing')) return null;
                var m = h.match(/[&|?]tab=([a-zA-Z0-9_-]+)/);
                return (m && m[1]) ? m[1] : null;
            }
            (function initTabFromHash(){
                var tab = parseTabFromHash();
                if (tab) { window.switchLeftTab(tab); }
            })();
            window.addEventListener('hashchange', function(){
                var tab = parseTabFromHash();
                if (tab) { window.switchLeftTab(tab); }
            });

            // åŸ‹ã‚è¾¼ã¿ãƒ¡ãƒ‡ã‚£ã‚¢ã‚®ãƒ£ãƒ©ãƒªãƒ¼ï¼ˆé¸æŠãƒ¢ãƒ¼ãƒ‰ï¼‰
            (function setupEmbeddedGallery(){
                const modal = document.createElement('div');
                modal.className = 'gallery-modal';
                modal.id = 'galleryModal';
                modal.innerHTML = `
                  <div class="gallery-frame">
                    <button class="gallery-close" id="closeGallery">âœ•</button>
                    <iframe src="/data/media-gallery/index.html?select=1" title="media-gallery"></iframe>
                  </div>`;
                document.body.appendChild(modal);
                const openBtn = byId('openEmbeddedGallery');
                const closeBtn = modal.querySelector('#closeGallery');

                const openGallery = () => {
                  if (!window.KamuiGalleryManager) {
                    alert('GalleryManager is not available.');
                    return;
                  }
                  const handleSelection = (data) => {
                    const candidates = [data.url, data.path].filter(Boolean);
                    const beforeImg = qs('#beforeImage img');
                    const trySet = (idx = 0) => {
                      if (!beforeImg || idx >= candidates.length) {
                        modal.classList.remove('open');
                        window.KamuiGalleryManager.clearOwner();
                        const diag = { received: data, tried: candidates };
                        if (window.openJsonModal) window.openJsonModal(JSON.stringify(diag, null, 2), 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼é¸æŠã‚¨ãƒ©ãƒ¼ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰');
                        return;
                      }
                      const src = candidates[idx];
                      const tester = new Image();
                      tester.onload = () => {
                        beforeImg.src = src;
                        beforeImg.alt = data.name || 'Selected';
                        try { addToReferenceGrid([src], true); } catch (_) {}
                        try { updateInputTray(); } catch (_) {}
                        modal.classList.remove('open');
                        window.KamuiGalleryManager.clearOwner();
                      };
                      tester.onerror = () => trySet(idx + 1);
                      tester.src = src;
                    };
                    trySet(0);
                  };

                  window.KamuiGalleryManager.setOwner('direct-drawing', handleSelection);
                  modal.classList.add('open');
                };

                const closeGallery = () => {
                  modal.classList.remove('open');
                  if (window.KamuiGalleryManager) {
                    window.KamuiGalleryManager.clearOwner();
                  }
                };

                if (openBtn) openBtn.addEventListener('click', openGallery);
                if (closeBtn) closeBtn.addEventListener('click', closeGallery);
            })();

            // MCPè¨­å®šç®¡ç†
            async function initializeMcpConfig() {
                // McpConfigManagerã®èª­ã¿è¾¼ã¿å¾…æ©Ÿ
                if (typeof McpConfigManager === 'undefined') {
                    debugLog('â³ McpConfigManagerã®èª­ã¿è¾¼ã¿å¾…æ©Ÿä¸­...');
                    let retries = 0;
                    while (typeof McpConfigManager === 'undefined' && retries < 50) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retries++;
                    }
                    if (typeof McpConfigManager === 'undefined') {
                        debugLog('âŒ McpConfigManagerã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        alert('MCPè¨­å®šç®¡ç†ã‚¯ãƒ©ã‚¹ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');
                        return;
                    }
                }

                try {
                    mcpConfigManager = new McpConfigManager();
                    await mcpConfigManager.loadDefaultConfig();
                    updateServerList();

                    // ãƒ‡ãƒãƒƒã‚°ï¼šã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã®ç¢ºèª
                    debugLog('ğŸš€ ã‚¢ãƒ—ãƒªåˆæœŸåŒ–å®Œäº†');
                    debugLog('ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ãƒã‚§ãƒƒã‚¯:', {
                        McpConfigManager: typeof McpConfigManager,
                        HttpMcpClient: typeof HttpMcpClient,
                        testMcpConnection: typeof window.testMcpConnection,
                        listMcpTools: typeof window.listMcpTools,
                        removeMcpServer: typeof window.removeMcpServer
                    });
                } catch (error) {
                    debugLog('âŒ MCPåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error.message);
                    console.error('MCP initialization failed:', error);
                }
            }

            // ===== Nano Banana (MCP) Edit çµ±åˆ =====
            const nanoBtn = byId('nanoBtn');
            const seedBtn = byId('seedBtn');
            if (nanoBtn) {
              nanoBtn.addEventListener('click', async function() {
                const nanoText = byId('nanoBtnText');
                const prompt = ((byId('promptInput')||{}).value || '').trim();
                if (!prompt) { alert('ç·¨é›†å†…å®¹ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

                // å…¥åŠ›ç”»åƒã‚’åé›†ï¼ˆè¤‡æ•°å¯¾å¿œï¼‰
                let inputUrls = collectRegisteredImageUrls();
                if (!inputUrls.length) { alert('å…¥åŠ›ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
                logShortList('å…¥åŠ›å€™è£œ', inputUrls, 10);
                // ã¾ã¨ã‚ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                try {
                  nanoLog('ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...' );
                  const uploaded = await uploadMany(inputUrls);
                  if (!uploaded.length) { alert('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ'); return; }
                  inputUrls = uploaded;
                  nanoLog('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº† (' + inputUrls.length + 'ä»¶)');
                } catch(exposeErr){ nanoLog('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ' + String((exposeErr && exposeErr.message) || exposeErr)); return; }

                // ãƒ­ã‚°UIæº–å‚™
                ensureNanoLog(); nanoLog('\u23F1 å®Ÿè¡Œé–‹å§‹');
                nanoLog('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: ' + prompt);
                logShortList('Input URLs', inputUrls, 10);

                // å¯¾è±¡MCPã‚µãƒ¼ãƒãƒ¼ã‚’æ¤œç´¢
                const servers = mcpConfigManager.getServers();
                const entries = Object.entries(servers||{});
                const found = entries.find(([_, cfg]) => (cfg.url||'').includes('nano-banana/edit'))
                           || entries.find(([_, cfg]) => (cfg.url||'').includes('/i2i/fal/nano-banana'))
                           || entries.find(([_, cfg]) => (cfg.url||'').includes('/t2i/fal/nano-banana'))
                           || entries[0];
                if (!found) {
                  alert('MCPã‚µãƒ¼ãƒãƒ¼ãŒæœªè¨­å®šã§ã™ã€‚MCPè¨­å®šã‚¿ãƒ–ã§ nano-banana/edit ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚');
                  nanoLog('\u26A0 MCPã‚µãƒ¼ãƒãƒ¼æœªè¨­å®š');
                  return;
                }
                const [serverName, serverConfig] = found;
                nanoLog('ä½¿ç”¨ã‚µãƒ¼ãƒãƒ¼: ' + serverName + ' â†’ ' + ((serverConfig && serverConfig.url)||''));

                let client;
                try {
                  nanoBtn.disabled = true;
                  nanoText.innerHTML = '<div class="loading-spinner"></div> é€ä¿¡ä¸­...';

                  // REST(T2I) çµŒè·¯: /t2i/fal/nano-banana ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯JSON-RPCã§ã¯ãªãç›´æ¥POST
                  const isT2I = /\/t2i\/fal\/nano-banana/i.test(serverConfig.url||'');
                  if (isT2I) {
                    let endpoint = serverConfig.url;
                  const kamuiCodeUrl = window.KAMUI_CODE_URL;
                  const kamuiCodeRegex = new RegExp(`^https?://${kamuiCodeUrl}/`, 'i');
                  if (kamuiCodeRegex.test(endpoint)) {
                    endpoint = `http://localhost:3001/kamui/${endpoint.replace(kamuiCodeRegex, '')}`;
                    }
                    if (/^http:\/\/localhost:3001\/mcp\//i.test(endpoint)) {
                      endpoint = endpoint.replace('/mcp/', '/kamui/');
                    }
                    const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
                    if (serverConfig && serverConfig.authorization) headers['Authorization'] = serverConfig.authorization;
                    try {
                      // RESTå´ãŒã‚»ãƒƒã‚·ãƒ§ãƒ³å¿…é ˆã®å ´åˆã«å‚™ãˆã€å¯¾å¿œã™ã‚‹ /mcp å´ã§ session ã‚’ç¢ºç«‹
                      const mcpEp = endpoint.replace('/kamui/', '/mcp/');
                      const tmp = new HttpMcpClient(mcpEp, { authorization: serverConfig.authorization, clientName: 'kamui-web-client', clientVersion: '1.0.0' });
                      await tmp.initialize();
                      if (tmp.sessionId) headers['mcp-session-id'] = tmp.sessionId;
                      nanoLog('t2i ç”¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºç«‹: ' + (tmp.sessionId||'(none)'));
                    } catch(_){ nanoLog('t2i ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºç«‹å¤±æ•—ï¼ˆç¶™ç¶šï¼‰'); }
                    const body = { prompt, num_images: 1 };
                    nanoLog('REST t2i submit â†’ ' + endpoint);
                    const resp = await fetch(endpoint, { method:'POST', headers, body: JSON.stringify(body) });
                    const text = await resp.text();
                    nanoLog('REST t2i å¿œç­”: ' + text.slice(0, 800));
                    let obj = null; try { obj = JSON.parse(text); } catch(_){ obj = null; }
                    const url = extractAnyUrl(obj) || extractAnyUrl(text) || null;
                    if (url) {
                      addGeneratedImage(url, prompt);
                      setAfterImage(url);
                      nanoLog('\u2705 ç”ŸæˆæˆåŠŸ: ' + url);
                    } else {
                      nanoLog('\u26A0 å¿œç­”ã«URLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                      alert('Nano Banana (t2i) ã®å¿œç­”ã«ç”»åƒURLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    }
                    nanoText.textContent = 'Nano Banana Edit';
                    return;
                  }

                  // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLã«è‡ªå‹•å¤‰æ›
                  let mcpUrl = serverConfig.url;
                  const kamuiCodeUrl = window.KAMUI_CODE_URL;
                  const kamuiCodeRegex = new RegExp(`^https?://${kamuiCodeUrl}/`, 'i');
                  if (kamuiCodeRegex.test(mcpUrl)) {
                    // ä¸ŠæµURLã‚’/mcpãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ãã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ã‚­ã‚·ã«å¤‰æ›
                    const pathPart = mcpUrl.replace(kamuiCodeRegex, '');
                    mcpUrl = 'http://localhost:3001/mcp/' + pathPart;
                    nanoLog('ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLå¤‰æ›: ' + mcpUrl);
                  }

                  client = new HttpMcpClient(mcpUrl, {
                    authorization: serverConfig.authorization,
                    clientName: 'kamui-web-client',
                    clientVersion: '1.0.0'
                  });
                  window.currentMcpClient = client;

                  nanoLog('initialize é–‹å§‹: ' + mcpUrl);
                  await client.initialize();
                  nanoLog('initialize å®Œäº†, sessionId=' + (client.sessionId||'(none)'));

                  // ãƒ„ãƒ¼ãƒ«è‡ªå‹•æ¤œå‡ºã¨å…¥åŠ›ã‚¹ã‚­ãƒ¼ãƒã«åˆã‚ã›ãŸå¼•æ•°ç”Ÿæˆ
                  let submitTool = 'nano_banana_edit_submit';
                  let statusTool = 'nano_banana_edit_status';
                  let resultTool = 'nano_banana_edit_result';
                  try {
                    const listed = await client.listTools();
                    const toolsArr = (listed && listed.result && listed.result.tools) || listed.tools || [];
                    const names = toolsArr.map(t=>String(t.name||''));
                    nanoLog('tools: ' + JSON.stringify(names));
                    const pick = {
                      submit(names){
                        // å„ªå…ˆ: 'submit' ã‚’å«ã‚€
                        let c = names.find(n=>/submit/i.test(n));
                        if (c) return c;
                        // æ¬¡: 'create|start|enqueue|queue|run|begin|process' ã‚’å«ã¿ã€ã‹ã¤ status/result/get ã‚’å«ã¾ãªã„
                        c = names.find(n=>/(create|start|enqueue|queue|run|begin|process|edit)/i.test(n) && !/(status|result|get)/i.test(n));
                        return c || null;
                      },
                      status(names){
                        return names.find(n=>/(status|poll)/i.test(n)) || null;
                      },
                      result(names){
                        return names.find(n=>/(result|get)/i.test(n)) || null;
                      }
                    };
                    submitTool = pick.submit(names) || submitTool;
                    statusTool = pick.status(names) || statusTool;
                    resultTool = pick.result(names) || resultTool;
                    window.__nano_status_tool__ = statusTool;
                    window.__nano_result_tool__ = resultTool;
                    nanoLog(`selected tools â†’ submit=${submitTool}, status=${statusTool}, result=${resultTool}`);

                    // ã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰image_urlsã®å‹ã‚’æ¨å®š
                    const submitMeta = toolsArr.find(t=>String(t.name||'')===submitTool);
                    try { if (submitMeta) nanoLog('submit schema: ' + JSON.stringify(submitMeta, null, 2)); } catch(_){ }
                    // æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿: 'image_urls' ã¯é…åˆ—
                    var submitArgs = { prompt, num_images: 1, image_urls: inputUrls };
                  } catch (_toolErr) {
                    // ãƒ„ãƒ¼ãƒ«ä¸€è¦§ãŒå–ã‚Œãªãã¦ã‚‚æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿ï¼ˆé…åˆ—ï¼‰ã‚’ä½¿ç”¨
                    var submitArgs = { prompt, num_images: 1, image_urls: inputUrls };
                  }

                  function pickRequestId(res){
                    try {
                      const cands = [res?.result?.request_id, res?.result?.id, res?.request_id, res?.id];
                      for (const v of cands){ if (typeof v === 'string' && v.trim()) return v.trim(); }
                      return null;
                    } catch(_){ return null; }
                  }
                  function pickRequestIdFromHeaders(client){
                    try {
                      const dbg = client && client.getDebugInfo ? client.getDebugInfo() : null;
                      const headers = (dbg && dbg.lastResponse && dbg.lastResponse.headers) || {};
                      const keys = Object.keys(headers);
                      const find = (re) => keys.find(k=>re.test(k));
                      const k = find(/^(x-)?(mcp-)?(request|job|task)[-_]?id$/i) || find(/request[-_]?id/i) || null;
                      const v = k ? headers[k] : null;
                      return (typeof v === 'string' && v.trim()) ? v.trim() : null;
                    } catch(_){ return null; }
                  }
                  function extractRequestIdFromText(obj){
                    try {
                      const txts = [];
                      const collect = (o)=>{
                        if (!o) return;
                        if (typeof o === 'string') txts.push(o);
                        else if (Array.isArray(o)) o.forEach(collect);
                        else if (typeof o === 'object') Object.values(o).forEach(collect);
                      };
                      collect(obj);
                      // 1) UUIDå½¢å¼ã‚’æœ€å„ªå…ˆã§æŠ½å‡ºï¼ˆMarkdownè£…é£¾ã‚„æ”¹è¡Œã‚’è¨±å®¹ï¼‰
                      const reUuid = /request[\s_-]*id[^A-Za-z0-9]{0,10}[*_`>~\s\r\n]*([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})/i;
                      for (const t of txts){
                        const m = String(t).match(reUuid);
                        if (m && m[1]) return m[1];
                      }
                      // 2) æ±ç”¨IDæŠ½å‡ºï¼ˆè£…é£¾æ–‡å­—ã®é™¤å»ã€ãƒã‚¤ãƒ•ãƒ³å«ã‚€IDã‚’å„ªå…ˆï¼‰
                      const reGeneric = /(request[\s_-]*id|task[\s_-]*id|job[\s_-]*id|id)\s*[:=]\s*[*_`>~"â€œâ€'\-]*\s*([A-Za-z0-9._\-]{6,})/i;
                      for (const t of txts){
                        const m = String(t).match(reGeneric);
                        if (m && m[2]){
                          const v = m[2].trim();
                          // JSONã® "id": 123456 ã®é¡ã‚’é¿ã‘ã‚‹ï¼ˆæ•°å­—ã®ã¿ã¯é™¤å¤–ï¼‰
                          if (!/^\d+$/.test(v)) return v;
                        }
                      }
                      return null;
                    } catch(_){ return null; }
                  }

                  let submitRes = null; let submitPayload = submitArgs; let reqId = null;

                  // JSON-RPC raw POSTï¼ˆæˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³å°‚ç”¨ï¼‰
                  async function rawCallTool(toolName, args){
                    const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
                    try { if (client && client.sessionId) headers['mcp-session-id'] = client.sessionId; } catch(_) {}
                    if (serverConfig && serverConfig.authorization) headers['Authorization'] = serverConfig.authorization;
                    const body = { jsonrpc:'2.0', id: Date.now(), method:'tools/call', params:{ name: toolName, arguments: args } };
                    nanoLog('raw submit JSON-RPC è©¦è¡Œ body=' + JSON.stringify(body));
                    // Seedreamã¯ãƒ­ãƒ¼ã‚«ãƒ«MCPãƒ–ãƒªãƒƒã‚¸çµŒç”±ã«çµ±ä¸€ï¼ˆå®Ÿåãƒ„ãƒ¼ãƒ«ã¸ã®å¤‰æ›ã‚ã‚Šï¼‰
                    const resp = await fetch(mcpUrl, { method:'POST', headers, body: JSON.stringify(body) });
                    const txt = await resp.text();
                    nanoLog('raw submit å¿œç­”: ' + txt.slice(0, 800));
                    const hdrs = {}; try { resp.headers.forEach((v,k)=>hdrs[k]=v); } catch(_){ }
                    nanoLog('raw submit headers: ' + JSON.stringify(hdrs));
                    let obj = null; try { obj = JSON.parse(txt); } catch(_){ obj = null; }
                    return { obj, txt, headers: hdrs };
                  }

                  function isMethodNotSupported(err){
                    if (!err) return false;
                    const code = Number(err.code);
                    if (code === -32601) return true;
                    const msg = String(err.message || err).toLowerCase();
                    return msg.includes('tool not found') || msg.includes('tools not supported') || msg.includes('method not found');
                  }

                  try {
                    nanoLog('submit é€ä¿¡ payload=' + JSON.stringify(submitArgs));
                    let raw = await rawCallTool(submitTool, submitArgs);
                    let r = raw.obj || {};

                    if (r && r.error && isMethodNotSupported(r.error)) {
                      nanoLog('tools/call ãŒæœªå¯¾å¿œã®ãŸã‚ direct å‘¼ã³å‡ºã—ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™');
                      try {
                        const fallbackObj = await rawCallDirect(submitTool, submitArgs);
                        nanoLog('direct submit å¿œç­”: ' + JSON.stringify(fallbackObj));
                        if (fallbackObj && !fallbackObj.error) {
                          r = fallbackObj;
                          raw = { obj: fallbackObj, txt: JSON.stringify(fallbackObj), headers: raw.headers || {} };
                        } else {
                          nanoLog('direct submit ã‚‚å¤±æ•—: ' + JSON.stringify(fallbackObj));
                        }
                      } catch (fallbackErr) {
                        nanoLog('direct submit ä¾‹å¤–: ' + String((fallbackErr && fallbackErr.message) || fallbackErr));
                      }
                    }

                    submitRes = r;
                    nanoLog('submit å¿œç­”: ' + JSON.stringify(r));

                    // æå‡ºç›´å¾Œã®å³æ™‚URLå®Œäº†ã¯æ‰±ã‚ãªã„ï¼ˆå…¥åŠ›ç”»åƒURLã®èª¤æ¤œå‡ºã‚’é˜²ãï¼‰
                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹â†’result ã®çµŒè·¯ã§ã®ã¿æœ€çµ‚URLã‚’é©ç”¨ã™ã‚‹

                    // request_id æŠ½å‡ºï¼ˆæœ¬æ–‡ãƒ†ã‚­ã‚¹ãƒˆã‚‚æ¤œæŸ»ï¼‰
                    reqId = pickRequestId(r) || extractRequestIdFromText((r && r.result) || r) || extractRequestIdFromText(raw.txt) || raw.headers['x-request-id'] || raw.headers['request-id'] || raw.headers['mcp-request-id'];

                    if (!reqId) {
                      nanoLog('âš ï¸ request_idæœªæ¤œå‡ºã€çµæœã‚’è¿”ã—ã¾ã™');
                      if (window.openJsonModal) {
                        window.openJsonModal(JSON.stringify(r, null, 2), 'submitå¿œç­”ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰');
                      }
                      nanoText.textContent = 'Nano Banana Edit';
                      return;
                    }
                  } catch(e) {
                    if (window.openJsonModal) window.openJsonModal(String((e && e.message) || e), 'submitã‚¨ãƒ©ãƒ¼');
                    throw e;
                  }

                  nanoLog('request_id=' + reqId);

                  // ãƒãƒ¼ãƒªãƒ³ã‚°ã¯è¡Œã‚ãšã€ä¸€åº¦ã ã‘ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèªã®ã¿ï¼ˆãƒ‡ãƒãƒƒã‚°ç›®çš„ï¼‰
                  nanoText.innerHTML = '<div class="loading-spinner"></div> ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèªä¸­...';

                  async function rawCallDirect(method, params){
                    const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
                    try { if (client && client.sessionId) headers['mcp-session-id'] = client.sessionId; } catch(_) {}
                    if (serverConfig && serverConfig.authorization) headers['Authorization'] = serverConfig.authorization;
                    const body = { jsonrpc:'2.0', id: Date.now(), method, params };
                    nanoLog('raw direct JSON-RPC è©¦è¡Œ body=' + JSON.stringify(body));
                    const resp = await fetch(mcpUrl, { method:'POST', headers, body: JSON.stringify(body) });
                    const txt = await resp.text();
                    nanoLog('raw direct å¿œç­”: ' + txt.slice(0, 800));
                    let obj = {}; try { obj = JSON.parse(txt); } catch(_) {}
                    return obj;
                  }

                  // å®Œäº†æ™‚ã®å˜ç™º result å–å¾—
                  async function performSingleResult(id){
                    try {
                      nanoText.innerHTML = '<div class="loading-spinner"></div> å–å¾—ä¸­...';
                      let got = (await rawCallTool(resultTool, { request_id: id })).obj;
                      if (!got || got.error) {
                        got = await rawCallDirect(resultTool, { request_id: id });
                      }
                      nanoLog('result å¿œç­”: ' + JSON.stringify(got));
                      const url = extractAnyUrl(got && got.result) || extractAnyUrl(got) || null;
                      if (!url) {
                        const info = { submitPayload, submitRes, result: got };
                        if (window.openJsonModal) {
                          window.openJsonModal(JSON.stringify(info,null,2),'çµæœURLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰');
                        } else {
                          alert('çµæœURLãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        }
                        nanoLog('\u26A0 çµæœURLã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                        return;
                      }
                      addGeneratedImage(url, prompt);
                      setAfterImage(url);
                      nanoLog('\u2705 å®Œäº†: ' + url);
                    } catch (e) {
                      nanoLog('result å–å¾—å¤±æ•—: ' + String((e && e.message)||e));
                    } finally {
                      // å¿…ãšUIã‚’åˆæœŸçŠ¶æ…‹ã¸æˆ»ã™
                      try { nanoBtn.disabled = false; } catch(_){ }
                      try { nanoText.textContent = 'Nano Banana Edit'; } catch(_){ }
                    }
                  }

                  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æŠ½å‡ºãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆMarkdownè£…é£¾/æ—¥æœ¬èªã‚‚è€ƒæ…®ï¼‰
                  function extractStatusState(obj){
                    try {
                      // 1) æ§‹é€ åŒ–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å„ªå…ˆ
                      const cand = [
                        obj && obj.result && obj.result.status,
                        obj && obj.status,
                        obj && obj.result && obj.result.state,
                        obj && obj.state
                      ].find(v => typeof v === 'string' && v.trim());
                      if (cand) return normalizeState(cand);

                      // 2) ãƒ†ã‚­ã‚¹ãƒˆèµ°æŸ»ï¼ˆMarkdownè£…é£¾ã‚’é™¤å»ã—ã€ã‚³ãƒ­ãƒ³å¾Œã®è£…é£¾ã‚‚è¨±å®¹ï¼‰
                      const texts = [];
                      const collect = (o)=>{
                        if (!o) return;
                        if (typeof o === 'string') texts.push(o);
                        else if (Array.isArray(o)) o.forEach(collect);
                        else if (typeof o === 'object') Object.values(o).forEach(collect);
                      };
                      collect(obj);
                      for (const t of texts){
                        const plain = String(t).replace(/[\*`_~>|]/g,'');
                        // ä¾‹: "Status: IN_PROGRESS" / "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: å‡¦ç†ä¸­"
                        const m1 = plain.match(/status\s*[:ï¼š]\s*([A-Za-z_\-\s]+)/i);
                        if (m1 && m1[1]) return normalizeState(m1[1]);
                        const m2 = plain.match(/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹\s*[:ï¼š]\s*([\p{L}_\-\s]+)/u);
                        if (m2 && m2[1]) return normalizeState(m2[1]);
                        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰æ¨å®š
                        const s = normalizeState(plain);
                        if (s) return s;
                      }
                      return null;
                    } catch(_) { return null; }
                  }

                  function normalizeState(s){
                    if (!s) return null;
                    const x = String(s).trim().toLowerCase().replace(/\s+/g,' ').replace(/[-]/g,'_');
                    // ç›´æ¥è¡¨è¨˜
                    if (/in[_ ]?progress|processing|running/.test(x)) return 'IN_PROGRESS';
                    if (/in[_ ]?queue|queued|waiting|pending/.test(x)) return 'IN_QUEUE';
                    if (/done|completed|complete|finished|ready|success|succeeded|ok/.test(x)) return 'DONE';
                    if (/error|failed|failure/.test(x)) return 'ERROR';
                    // æ—¥æœ¬èª
                    if (/å‡¦ç†ä¸­/.test(x)) return 'IN_PROGRESS';
                    if (/å¾…æ©Ÿ|ã‚­ãƒ¥ãƒ¼|ä¿ç•™/.test(x)) return 'IN_QUEUE';
                    if (/å®Œäº†|æˆåŠŸ/.test(x)) return 'DONE';
                    if (/å¤±æ•—|ã‚¨ãƒ©ãƒ¼/.test(x)) return 'ERROR';
                    // ãã‚Œã£ã½ã„å˜èªãŒå«ã¾ã‚Œã¦ã„ã‚Œã°IN_PROGRESSæ‰±ã„
                    if (/process|progress/.test(x)) return 'IN_PROGRESS';
                    return null;
                  }

                  // ã¾ãš tools/call ã® status ãƒ„ãƒ¼ãƒ«ã‚’1å›ã ã‘
                  let st = (await rawCallTool(statusTool, { request_id: reqId })).obj;
                  // tools/call ãŒæœªå¯¾å¿œç­‰ã®å¯èƒ½æ€§ã«å‚™ãˆã€method=ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ„ãƒ¼ãƒ«å ã§ã‚‚1å›ã ã‘è©¦è¡Œ
                  if (!st || st.error) {
                    st = await rawCallDirect(statusTool, { request_id: reqId });
                  }
                  const state1 = extractStatusState(st) || '(unknown)';
                  nanoLog('status ä¸€å›å¿œç­”: ' + JSON.stringify(st));
                  nanoLog('status state: ' + state1);

                  // å®Œäº†ãªã‚‰å³åº§ã«resultã‚’ä¸€å›å®Ÿè¡Œã—ã¦çµ‚äº†
                  if (state1 === 'DONE') {
                    await performSingleResult(reqId);
                    return;
                  }

                  // æŒ‡å®šç§’ã”ã¨ã« N å›ã¾ã§è¿½åŠ ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¨ãƒ©ãƒ¼å¿œç­”ã§åœæ­¢ï¼‰
                  const reDelaySec = (window.__nano_recheck_delay_sec__ && Number(window.__nano_recheck_delay_sec__)) || 5;
                  const reTimes = (window.__nano_recheck_times__ && Number(window.__nano_recheck_times__)) || 20; // 1ç§’Ã—20å›
                  let __nano_recheck_stopped__ = false;
                  function setCheckingLabel(i){
                    try { nanoText.innerHTML = `<div class=\"loading-spinner\"></div> å†ãƒã‚§ãƒƒã‚¯ä¸­... (${i}/${reTimes})`; } catch(_){}
                  }
                  setCheckingLabel(0);
                  (function schedule(i){
                    if (i > reTimes) { try { nanoText.textContent = 'Nano Banana Edit'; } catch(_){} return; }
                    try {
                      setTimeout(async ()=>{
                        try {
                          if (__nano_recheck_stopped__) { try { nanoText.textContent = 'Nano Banana Edit'; } catch(_){} return; }
                          nanoLog(`â³ ${reDelaySec}ç§’å¾Œã«å†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ (nano ${i}/${reTimes})...`);
                          let stN = (await rawCallTool(statusTool, { request_id: reqId })).obj;
                          if (!stN || stN.error) stN = await rawCallDirect(statusTool, { request_id: reqId });
                          const stateN = extractStatusState(stN) || '(unknown)';
                          nanoLog('status å†ãƒã‚§ãƒƒã‚¯å¿œç­”: ' + JSON.stringify(stN));
                          nanoLog(`status state (#${i+1}): ` + stateN);
                          if (stN && stN.error) { nanoLog('â›” ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚Šå†ãƒã‚§ãƒƒã‚¯åœæ­¢'); try { nanoText.textContent = 'Nano Banana Edit'; } catch(_){} return; }
                          if (stateN === 'DONE') {
                            __nano_recheck_stopped__ = true;
                            await performSingleResult(reqId);
                            return;
                          }
                          setCheckingLabel(i);
                          schedule(i+1);
                        } catch (e2) {
                          nanoLog('status å†ãƒã‚§ãƒƒã‚¯å¤±æ•—: ' + String((e2 && e2.message)||e2));
                          schedule(i+1);
                        }
                      }, reDelaySec * 1000);
                    } catch(_){}
                  })(1);

                  // ãƒ‡ãƒãƒƒã‚°ç›®çš„ã®ãŸã‚ã“ã“ã§çµ‚äº†
                  return;

                } catch(error) {
                  const info = {
                    error: String((error && error.message) || error),
                    server: (serverConfig && serverConfig.url),
                    hasAuth: !!(serverConfig && serverConfig.authorization),
                    sessionId: (client && client.sessionId) || null,
                    debug: (client && client.getDebugInfo ? client.getDebugInfo() : null)
                  };
                  const json = JSON.stringify(info, null, 2);
                  if (window.openJsonModal) { window.openJsonModal(json, 'Nano Banana Edit å¤±æ•—ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); }
                  else { alert('Nano Banana Edit ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + json); }
                  nanoLog('\u274C å¤±æ•—: ' + (info.error || 'unknown'));
                } finally {
                  nanoBtn.disabled = false;
                  nanoText.textContent = 'Nano Banana Edit';
                }
              });
            }

            // ===== Seedream (MCP) Edit è¿½åŠ  =====
            if (seedBtn) {
              seedBtn.addEventListener('click', async function() {
                const seedText = byId('seedBtnText');
                const prompt = ((byId('promptInput')||{}).value || '').trim();
                if (!prompt) { alert('ç·¨é›†å†…å®¹ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

                // å…¥åŠ›ç”»åƒã‚’åé›†ï¼ˆè¤‡æ•°å¯¾å¿œï¼‰
                let inputUrls = collectRegisteredImageUrls();
                if (!inputUrls.length) { alert('å…¥åŠ›ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
                logShortList('å…¥åŠ›å€™è£œ', inputUrls, 10);
                // ã¾ã¨ã‚ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                try {
                  nanoLog('ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...(seedream)');
                  const uploaded = await uploadMany(inputUrls);
                  if (!uploaded.length) { alert('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ'); return; }
                  inputUrls = uploaded;
                  nanoLog('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº† (' + inputUrls.length + 'ä»¶)');
                } catch(exposeErr){ nanoLog('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ' + String((exposeErr && exposeErr.message) || exposeErr)); return; }

                ensureNanoLog(); nanoLog('\u23F1 Seedream å®Ÿè¡Œé–‹å§‹');
                nanoLog('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: ' + prompt);
                logShortList('Input URLs', inputUrls, 10);

                const servers = mcpConfigManager.getServers();
                const entries = Object.entries(servers||{});
                const found = entries.find(([_, cfg]) => (cfg.url||'').includes('/i2i/fal/bytedance/seedream/v4'))
                           || entries.find(([_, cfg]) => (cfg.url||'').includes('/i2i/fal/bytedance/seedream'))
                           || entries.find(([_, cfg]) => (cfg.url||'').includes('/t2i/fal/bytedance/seedream'))
                           || entries[0];
                if (!found) {
                  alert('MCPã‚µãƒ¼ãƒãƒ¼ãŒæœªè¨­å®šã§ã™ã€‚MCPè¨­å®šã‚¿ãƒ–ã§ seedream/v4 ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚');
                  nanoLog('\u26A0 MCPã‚µãƒ¼ãƒãƒ¼æœªè¨­å®š (seedream)');
                  return;
                }
                const [serverName, serverConfig] = found;
                nanoLog('ä½¿ç”¨ã‚µãƒ¼ãƒãƒ¼(Seedream): ' + serverName + ' â†’ ' + ((serverConfig && serverConfig.url)||''));

                let client;
                try {
                  seedBtn.disabled = true;
                  seedText.innerHTML = '<div class="loading-spinner"></div> é€ä¿¡ä¸­...';

                  // Seedream: RESTçµŒè·¯ã¯ä¸ŠæµãŒJSON-RPCã§å¿œç­”ã™ã‚‹ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã€MCPçµŒè·¯ã«çµ±ä¸€

                  // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLã«è‡ªå‹•å¤‰æ›ï¼ˆMCPçµŒè·¯ï¼‰
                  let mcpUrl = serverConfig.url;
                  const kamuiCodeUrl = window.KAMUI_CODE_URL;
                  const kamuiCodeRegex = new RegExp(`^https?://${kamuiCodeUrl}/`, 'i');
                  if (kamuiCodeRegex.test(mcpUrl)) {
                    const pathPart = mcpUrl.replace(kamuiCodeRegex, '');
                    mcpUrl = 'http://localhost:3001/mcp/' + pathPart;
                    nanoLog('ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLå¤‰æ›: ' + mcpUrl);
                  }

                  client = new HttpMcpClient(mcpUrl, {
                    authorization: serverConfig.authorization,
                    clientName: 'kamui-web-client',
                    clientVersion: '1.0.0'
                  });
                  window.currentMcpClient = client;

                  nanoLog('initialize é–‹å§‹: ' + mcpUrl);
                  await client.initialize();
                  nanoLog('initialize å®Œäº†, sessionId=' + (client.sessionId||'(none)'));

                  let submitTool = 'seedream_edit_submit';
                  let statusTool = 'seedream_edit_status';
                  let resultTool = 'seedream_edit_result';
                  let overrideSubmit = null, overrideStatus = null, overrideResult = null;
                  try {
                    const u = new URL(serverConfig.url);
                    const sp = u.searchParams;
                    overrideSubmit = sp.get('tool_submit');
                    overrideStatus = sp.get('tool_status');
                    overrideResult = sp.get('tool_result');
                    if (overrideSubmit || overrideStatus || overrideResult) {
                      nanoLog('URL overrides: ' + JSON.stringify({ overrideSubmit, overrideStatus, overrideResult }));
                    }
                  } catch(_){}
                  try {
                    const listed = await client.listTools();
                    const toolsArr = (listed && listed.result && listed.result.tools) || listed.tools || [];
                    const names = toolsArr.map(t=>String(t.name||''));
                    nanoLog('tools: ' + JSON.stringify(names));
                    const pick = {
                      submit(names){
                        let c = names.find(n=>/submit/i.test(n));
                        if (c) return c;
                        c = names.find(n=>/(create|start|enqueue|queue|run|begin|process|edit)/i.test(n) && !/(status|result|get)/i.test(n));
                        return c || null;
                      },
                      status(names){ return names.find(n=>/(status|poll)/i.test(n)) || null; },
                      result(names){ return names.find(n=>/(result|get)/i.test(n)) || null; }
                    };
                    submitTool = overrideSubmit || pick.submit(names) || submitTool;
                    statusTool = overrideStatus || pick.status(names) || statusTool;
                    resultTool = overrideResult || pick.result(names) || resultTool;
                    window.__seed_status_tool__ = statusTool;
                    window.__seed_result_tool__ = resultTool;
                    nanoLog(`selected tools â†’ submit=${submitTool}, status=${statusTool}, result=${resultTool}`);

                    const submitMeta = toolsArr.find(t=>String(t.name||'')===submitTool);
                    try { if (submitMeta) nanoLog('submit schema: ' + JSON.stringify(submitMeta, null, 2)); } catch(_){ }
                  } catch(_){ /* ãƒ„ãƒ¼ãƒ«ä¸€è¦§ãŒå–ã‚Œãªãã¦ã‚‚æ—¢å®šå¼•æ•°ã§ç¶šè¡Œ */ }

                  async function rawCallTool(toolName, args){
                    const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
                    try { if (client && client.sessionId) headers['mcp-session-id'] = client.sessionId; } catch(_) {}
                    if (serverConfig && serverConfig.authorization) headers['Authorization'] = serverConfig.authorization;
                    const body = { jsonrpc:'2.0', id: Date.now(), method:'tools/call', params:{ name: toolName, arguments: args } };
                    nanoLog('raw submit JSON-RPC è©¦è¡Œ body=' + JSON.stringify(body));
                    // 1st: ãƒ­ãƒ¼ã‚«ãƒ«MCPï¼ˆå®‰å®šãƒ»CORSå¯¾å¿œï¼‰
                    let resp = await fetch(mcpUrl, { method:'POST', headers, body: JSON.stringify(body) });
                    let txt = await resp.text();
                    nanoLog('raw submit å¿œç­”: ' + txt.slice(0, 800));
                    const hdrs = {}; try { resp.headers.forEach((v,k)=>hdrs[k]=v); } catch(_){ }
                    nanoLog('raw submit headers: ' + JSON.stringify(hdrs));
                    let obj = null; try { obj = JSON.parse(txt); } catch(_){ obj = null; }
                    // Fallback: ç›´æ¥ä¸Šæµï¼ˆå¾Œæ–¹äº’æ›ã€æ—¢å­˜æ¤œå‡ºã‚’å£Šã•ãªã„ï¼‰
                    if (!resp.ok || (obj && obj.error && /tool\s+not\s+found|-32601|tools\s+not\s+supported/i.test(String(obj.error.message||'')))) {
                      try {
                        const resp2 = await fetch(serverConfig.url, { method:'POST', headers, body: JSON.stringify(body) });
                        const txt2 = await resp2.text();
                        nanoLog('raw submit å¿œç­”(fallback): ' + txt2.slice(0, 800));
                        const hdrs2 = {}; try { resp2.headers.forEach((v,k)=>hdrs2[k]=v); } catch(_){ }
                        nanoLog('raw submit headers(fallback): ' + JSON.stringify(hdrs2));
                        let obj2 = null; try { obj2 = JSON.parse(txt2); } catch(_){ obj2 = null; }
                        return { obj: obj2, txt: txt2, headers: hdrs2 };
                      } catch(_){ /* ignore, keep first */ }
                    }
                    return { obj, txt, headers: hdrs };
                  }

                  const submitArgs = { prompt, num_images: 1, image_urls: inputUrls };
                  nanoLog('submit é€ä¿¡ payload=' + JSON.stringify(submitArgs));
                  const raw = await rawCallTool(submitTool, submitArgs);
                  const r = raw.obj || {};
                  nanoLog('submit å¿œç­”: ' + JSON.stringify(r));

                  function pickRequestId(res){
                    try {
                      const cands = [res?.result?.request_id, res?.result?.id, res?.request_id, res?.id];
                      for (const v of cands){ if (typeof v === 'string' && v.trim()) return v.trim(); }
                      return null;
                    } catch(_){ return null; }
                  }

                  function extractRequestIdFromText(obj){
                    try {
                      const txts = [];
                      const collect = (o)=>{
                        if (!o) return;
                        if (typeof o === 'string') txts.push(o);
                        else if (Array.isArray(o)) o.forEach(collect);
                        else if (typeof o === 'object') Object.values(o).forEach(collect);
                      };
                      collect(obj);
                      // JSONæ–‡å­—åˆ—å†…ã® request_id ã‚’æŠ½å‡ºï¼ˆMarkdownè£…é£¾ã‚‚è¨±å®¹ï¼‰
                      const reUuid = /request[\s_-]*id[^A-Za-z0-9]{0,10}[*_`>~\s\r\n]*([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})/i;
                      for (const t of txts){
                        const m = String(t).match(reUuid);
                        if (m && m[1]) return m[1];
                        // JSONã¨ã—ã¦parseå¯èƒ½ãªã‚‰ä¸­ã‹ã‚‰ã‚‚å†å¸°çš„ã«æ¢ã™
                        try { const j = JSON.parse(String(t)); const v = extractRequestIdFromText(j); if (v) return v; } catch(_){ }
                      }
                      return null;
                    } catch(_){ return null; }
                  }

                  const reqId = pickRequestId(r)
                              || extractRequestIdFromText((r && r.result) || r)
                              || extractRequestIdFromText(raw.txt)
                              || (raw.headers['x-request-id'] || raw.headers['request-id'] || raw.headers['mcp-request-id']);
                  if (!reqId) {
                    nanoLog('âš ï¸ request_idæœªæ¤œå‡ºã€çµæœã‚’è¿”ã—ã¾ã™');
                    if (window.openJsonModal) window.openJsonModal(JSON.stringify(r, null, 2), 'Seedream submitå¿œç­”ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰');
                    seedText.textContent = 'Seedream Edit';
                    return;
                  }
                  nanoLog('request_id=' + reqId);

                  seedText.innerHTML = '<div class="loading-spinner"></div> ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèªä¸­...';

                  async function rawCallDirect(method, params){
                    const headers = { 'Content-Type':'application/json', 'Accept':'application/json' };
                    try { if (client && client.sessionId) headers['mcp-session-id'] = client.sessionId; } catch(_) {}
                    if (serverConfig && serverConfig.authorization) headers['Authorization'] = serverConfig.authorization;
                    const body = { jsonrpc:'2.0', id: Date.now(), method, params };
                    nanoLog('raw direct JSON-RPC è©¦è¡Œ body=' + JSON.stringify(body));
                    // 1st: ãƒ­ãƒ¼ã‚«ãƒ«MCP
                    try {
                      const resp = await fetch(mcpUrl, { method:'POST', headers, body: JSON.stringify(body) });
                      const txt = await resp.text();
                      nanoLog('raw direct å¿œç­”: ' + txt.slice(0, 800));
                      let obj = {}; try { obj = JSON.parse(txt); } catch(_){ }
                      // toolæœªå¯¾å¿œãªã‚‰fallback
                      if (obj && obj.error && /tool\s+not\s+found|-32601|tools\s+not\s+supported/i.test(String(obj.error.message||''))) throw new Error('fallback');
                      return obj;
                    } catch(_fallback){
                      // 2nd: ç›´æ¥ä¸Šæµ
                      const resp2 = await fetch(serverConfig.url, { method:'POST', headers, body: JSON.stringify(body) });
                      const txt2 = await resp2.text();
                      nanoLog('raw direct å¿œç­”(fallback): ' + txt2.slice(0, 800));
                      let obj2 = {}; try { obj2 = JSON.parse(txt2); } catch(_){ }
                      return obj2;
                    }
                  }

                  async function performSingleResult(id){
                    try {
                      seedText.innerHTML = '<div class="loading-spinner"></div> å–å¾—ä¸­...';
                      let got = (await rawCallTool(resultTool, { request_id: id })).obj;
                      if (!got || got.error) got = await rawCallDirect(resultTool, { request_id: id });
                      nanoLog('result å¿œç­”: ' + JSON.stringify(got));
                      const url = extractAnyUrl(got && got.result) || extractAnyUrl(got) || null;
                      if (url) {
                        addGeneratedImage(url, prompt);
                        setAfterImage(url);
                        nanoLog('\u2705 å®Œäº†: ' + url);
                      } else {
                        nanoLog('\u26A0 çµæœURLã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                      }
                    } catch(e) {
                      nanoLog('result å–å¾—å¤±æ•—: ' + String((e && e.message)||e));
                    } finally {
                      seedText.textContent = 'Seedream Edit';
                    }
                  }

                  // å˜ç™º status â†’ å®Œäº†ãªã‚‰ result
                  let st = (await rawCallTool(statusTool, { request_id: reqId })).obj;
                  if (!st || st.error) st = await rawCallDirect(statusTool, { request_id: reqId });
                  nanoLog('status ä¸€å›å¿œç­”: ' + JSON.stringify(st));

                  function normalizeStateSeed(x){
                    if (!x) return null;
                    const s = String(x).trim().toLowerCase();
                    if (/in[_ ]?progress|processing|running/.test(s)) return 'IN_PROGRESS';
                    if (/in[_ ]?queue|queued|waiting|pending/.test(s)) return 'IN_QUEUE';
                    if (/done|completed|complete|finished|ready|success|succeeded|ok/.test(s)) return 'DONE';
                    if (/error|failed|failure/.test(s)) return 'ERROR';
                    return null;
                  }

                  function extractStatusStateSeedream(obj){
                    try {
                      // 1) æ§‹é€ åŒ–
                      const direct = obj?.result?.status || obj?.status || obj?.result?.state || obj?.state;
                      const n1 = normalizeStateSeed(direct);
                      if (n1) return n1;
                      // 2) ãƒ†ã‚­ã‚¹ãƒˆèµ°æŸ»ï¼ˆcontent[*].text ãªã©ï¼‰
                      const texts = [];
                      (function collect(o){
                        if (!o) return;
                        if (typeof o === 'string') texts.push(o);
                        else if (Array.isArray(o)) o.forEach(collect);
                        else if (typeof o === 'object') Object.values(o).forEach(collect);
                      })(obj);
                      for (const t of texts){
                        const plain = String(t);
                        // JSONæ–‡å­—åˆ—ãªã‚‰parseã—ã¦ status ã‚’å†å¸°çš„ã«æŠ½å‡º
                        try {
                          const j = JSON.parse(plain);
                          const n2 = extractStatusStateSeedream(j);
                          if (n2) return n2;
                        } catch(_){}
                        // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æ¨å®š
                        const norm = normalizeStateSeed(plain);
                        if (norm) return norm;
                      }
                      // 3) æœ€å¾Œã«å…¨æ–‡ã‚’å¯¾è±¡ã«ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯
                      const str = JSON.stringify(obj||{});
                      const n3 = normalizeStateSeed(str);
                      if (n3) return n3;
                    } catch(_){ }
                    return null;
                  }

                  const state = extractStatusStateSeedream(st) || '(unknown)';
                  nanoLog('status state: ' + state);

                  // å³å®Œäº†ãªã‚‰çµæœå–å¾—ã—ã¦çµ‚äº†
                  if (state === 'DONE') {
                    await performSingleResult(reqId);
                    return;
                  }

                  // é€²è¡Œä¸­/ã‚­ãƒ¥ãƒ¼ä¸­ã¯ãƒãƒ¼ãƒªãƒ³ã‚°ï¼ˆNano BananaåŒæ§˜ã®æŒ™å‹•ï¼‰
                  const reDelaySecSeed = (window.__seed_recheck_delay_sec__ && Number(window.__seed_recheck_delay_sec__)) || 10;
                  const reTimesSeed   = (window.__seed_recheck_times__ && Number(window.__seed_recheck_times__)) || 12; // 10ç§’Ã—12å›=æœ€å¤§ç´„2åˆ†
                  let __seed_recheck_stopped__ = false;

                  function setCheckingLabel(i){
                    seedText.innerHTML = `<div class="loading-spinner"></div> å†ãƒã‚§ãƒƒã‚¯ä¸­... (${i}/${reTimesSeed})`;
                  }

                  setCheckingLabel(0);

                  (function scheduleSeed(i){
                    if (i > reTimesSeed || __seed_recheck_stopped__) {
                      seedText.textContent = 'Seedream Edit';
                      return;
                    }
                    setTimeout(async () => {
                      if (__seed_recheck_stopped__) { seedText.textContent = 'Seedream Edit'; return; }
                      try {
                        nanoLog(`â³ ${reDelaySecSeed}ç§’å¾Œã«å†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ (seedream ${i}/${reTimesSeed})...`);
                        let stN = (await rawCallTool(statusTool, { request_id: reqId })).obj;
                        if (!stN || stN.error) stN = await rawCallDirect(statusTool, { request_id: reqId });
                        const stateN = extractStatusStateSeedream(stN) || '(unknown)';
                        nanoLog('status å†ãƒã‚§ãƒƒã‚¯å¿œç­”(seedream): ' + JSON.stringify(stN));
                        nanoLog(`status state (seedream #${i}): ` + stateN);
                        if (stN && stN.error) {
                          nanoLog('â›” ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚Šå†ãƒã‚§ãƒƒã‚¯åœæ­¢(seedream)');
                          seedText.textContent = 'Seedream Edit';
                          return;
                        }
                        if (stateN === 'DONE') {
                          __seed_recheck_stopped__ = true;
                          await performSingleResult(reqId);
                          return;
                        }
                        setCheckingLabel(i);
                        scheduleSeed(i + 1);
                      } catch (pollErr) {
                        nanoLog('âš ï¸ å†ãƒã‚§ãƒƒã‚¯ä¸­ã«ä¾‹å¤–(seedream): ' + String((pollErr && pollErr.message) || pollErr));
                        scheduleSeed(i + 1);
                      }
                    }, reDelaySecSeed * 1000);
                  })(1);
                } catch(error) {
                  const info = {
                    error: String((error && error.message) || error),
                    server: (serverConfig && serverConfig.url),
                    hasAuth: !!(serverConfig && serverConfig.authorization),
                    sessionId: (client && client.sessionId) || null,
                    debug: (client && client.getDebugInfo ? client.getDebugInfo() : null)
                  };
                  const json = JSON.stringify(info, null, 2);
                  if (window.openJsonModal) { window.openJsonModal(json, 'Seedream Edit å¤±æ•—ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); }
                  else { alert('Seedream Edit ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + json); }
                  nanoLog('\u274C å¤±æ•—: ' + (info.error || 'unknown'));
                } finally {
                  seedBtn.disabled = false;
                  seedText.textContent = 'Seedream Edit';
                }
              });
            }

            var uploadBaseCandidates = window.__UPLOAD_BASE_CANDIDATES__ = window.__UPLOAD_BASE_CANDIDATES__ || (function(){

              if (!window.__UPLOAD_BASE__ && window.API_BASE_URL) window.__UPLOAD_BASE__ = window.API_BASE_URL;

              if (!window.__UPLOAD_BASE__ && window.location && window.location.port === '3001') window.__UPLOAD_BASE__ = window.location.origin;

              if (!window.__UPLOAD_BASE__ && window.location && window.location.port === '8888') window.__UPLOAD_BASE__ = window.location.origin;

              const list = [];

              if (window.__UPLOAD_BASE__) list.push(window.__UPLOAD_BASE__);

              if (window.API_BASE_URL) list.push(window.API_BASE_URL);

              list.push(
                'http://localhost:3001','http://127.0.0.1:3001',
                'http://localhost:7777','http://127.0.0.1:7777',
                'http://localhost:8888','http://127.0.0.1:8888'
              );

              if (window.location && window.location.origin) list.push(window.location.origin);

              return list

                .map(v => (typeof v === 'string' ? v : String(v || '')))

                .map(v => v.trim())

                .filter(Boolean)

                .map(v => v.replace(/\/+$/, ''));

            })();

            function toAbsoluteUrl(u){
              try {
                if (!u) return u;
                if (/^data:/i.test(u) || /^blob:/i.test(u)) return u;
                if (/^https?:\/\//i.test(u)) return u;
                if (u.startsWith('/')) {
                  const base = uploadBaseCandidates.find(Boolean);
                  if (base) {
                    const normalizedBase = base.replace(/\/+$/, '');
                    const normalizedPath = u.replace(/^\/+/, '');
                    return normalizedBase + '/' + normalizedPath;
                  }
                  return u;
                }
                const a = document.createElement('a');
                a.href = u;
                if (a.protocol && a.host) return a.href;
                const fallbackBase = uploadBaseCandidates.find(Boolean);
                if (fallbackBase) {
                  const normalizedBase = fallbackBase.replace(/\/+$/, '');
                  const normalizedPath = u.replace(/^\/+/, '');
                  return normalizedBase + '/' + normalizedPath;
                }
                return u;
              } catch(_) { return u; }
            }

            async function postJsonThroughCandidates(path, payload, label){
              const seen = new Set();
              const errors = [];
              for (const baseRaw of uploadBaseCandidates){
                if (!baseRaw) continue;
                const base = String(baseRaw).replace(/\/+$/, '');
                if (!base) continue;
                if (seen.has(base)) continue;
                seen.add(base);
                const endpoint = base + path;
                try {
                  if (label) nanoLog(`${label}è©¦è¡Œ: ${endpoint}`);
                  const resp = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                  });
                  const data = await resp.json().catch(() => ({}));
                  if (resp.ok) {
                    return { ok: true, endpoint, data };
                  }
                  errors.push({ endpoint, status: resp.status, data });
                } catch (err) {
                  errors.push({ endpoint, error: String((err && err.message) || err) });
                }
              }
              return { ok: false, errors };
            }



            // ä»¥å‰ã®ãƒãƒ¼ãƒªãƒ³ã‚°é–¢æ•°ã¯ä½¿ç”¨ã—ãªã„ï¼ˆå˜ç™ºå–å¾—æ–¹é‡ï¼‰

            // å…¥åŠ›ç”»åƒãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆè¤‡æ•°å¯¾å¿œï¼‰
            async function uploadOne(url){
              const abs = toAbsoluteUrl(url);
              let uploadAttempt = await postJsonThroughCandidates('/upload', { url: abs }, 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰');
              if (uploadAttempt.ok) {
                const data = uploadAttempt.data || {};
                const uploaded = data.uploaded_url || data.url || data.public_url;
                if (uploaded) return uploaded;
                uploadAttempt = { ok: false, errors: [{ endpoint: uploadAttempt.endpoint, status: 'ok-but-no-url', data }] };
              }
              let exposeAttempt = await postJsonThroughCandidates('/expose', { url: abs }, 'å…¬é–‹');
              if (exposeAttempt.ok) {
                const data2 = exposeAttempt.data || {};
                const exposed = data2.public_url || data2.url || data2.uploaded_url;
                if (exposed) return exposed;
                exposeAttempt = { ok: false, errors: [{ endpoint: exposeAttempt.endpoint, status: 'ok-but-no-url', data: data2 }] };
              }
              nanoLog('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—: ' + abs);
              try {
                console.warn('upload failed', { target: abs, uploadAttempt, exposeAttempt });
              } catch(_){ /* noop */ }
              if (window.openJsonModal) {
                const info = {
                  target: abs,
                  uploadErrors: uploadAttempt && uploadAttempt.errors,
                  exposeErrors: exposeAttempt && exposeAttempt.errors
                };
                try { window.openJsonModal(JSON.stringify(info, null, 2), 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); } catch(_){ }
              }
              return null;
            }

            function collectRegisteredImageUrls(){
              try {
                const useAll = !!window.__use_all_reference_images__;
                const sel = useAll ? '#referenceGrid img' : '#referenceGrid .reference-item.selected img';
                let arr = Array.from(qsa(sel)).map(el=>el && el.src).filter(Boolean);
                const manualSet = window.__input_manual_set__;
                if (manualSet && manualSet.size) {
                  arr.push(...Array.from(manualSet));
                }
                const beforeImg = qs('#beforeImage img');
                if (arr.length === 0 && beforeImg && beforeImg.src) arr.push(beforeImg.src);
                // use_all ã®ã¨ãã¯é™¤å¤–ãƒªã‚¹ãƒˆã‚’é©ç”¨
                if (useAll && window.__input_exclude_set__ && window.__input_exclude_set__.size){
                  arr = arr.filter(u => !window.__input_exclude_set__.has(toAbsoluteUrl(u)));
                }
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã®ã¿ã®å ´åˆã€æŒ‡å®šæšæ•°ã¶ã‚“è¤‡è£½
                if (arr.length === 1 && /^data:image\/png;base64/.test(arr[0]) && window.__default_placeholder_count__ > 1){
                  const copies = new Array(window.__default_placeholder_count__-1).fill(arr[0]);
                  arr.push(...copies);
                }
                // çµ¶å¯¾URLåŒ– + é‡è¤‡æ’é™¤
                const uniq = Array.from(new Set(arr.map(toAbsoluteUrl)));
                const limit = Math.max(1, Number(window.__max_input_images__)||10);
                return uniq.slice(0, limit);
              } catch(_) { return []; }
            }

            async function uploadMany(urls){
              const out = [];
              for (const u of urls){ const up = await uploadOne(u); if (up) out.push(up); }
              return out;
            }

            // è¡¨ç¤ºç”¨ãƒ•ã‚¡ã‚¤ãƒ«åã®çŸ­ç¸®ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°éå¤šã®æŠ‘åˆ¶ï¼‰
            function fileNameFromUrl(u){
              try {
                if (/^data:/i.test(u)){
                  const m = String(u).match(/^data:([^;,]+)/i); const mime = (m && m[1]) || '';
                  const ext = /png/i.test(mime) ? 'png' : /jpe?g/i.test(mime) ? 'jpg' : /webp/i.test(mime) ? 'webp' : /gif/i.test(mime) ? 'gif' : 'bin';
                  return 'inline.' + ext;
                }
                const a = document.createElement('a'); a.href = toAbsoluteUrl(u);
                let name = (a.pathname.split('/').pop() || '').trim();
                if (!name) name = a.hostname || 'file';
                return name;
              } catch(_) { return 'file'; }
            }
            function shortName(u, n){
              const s = fileNameFromUrl(u);
              const limit = Math.max(4, Number(n)||10);
              return s.length > limit ? (s.slice(0, limit) + 'â€¦') : s;
            }
            function logShortList(prefix, urls, n){
              try { nanoLog(`${prefix} ${urls.length}ä»¶: ` + urls.map(u=>shortName(u,n||10)).join(', ')); } catch(_){}
            }

            function updateInputTray(){
              try {
                const tray = byId('inputTray');
                const info = byId('inputTrayInfo');
                const useAllEl = byId('toggleUseAll');
                if (!tray || !info) return;
                // ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤ºã¨åŒæœŸ
                if (useAllEl) useAllEl.checked = !!window.__use_all_reference_images__;
                const urls = collectRegisteredImageUrls();
                const manualSet = window.__input_manual_set__;
                const excludedSet = window.__input_exclude_set__;
                tray.innerHTML = '';
                urls.forEach(u => {
                  const abs = toAbsoluteUrl(u);
                  const isManual = !!(manualSet && manualSet.has(abs));
                  const isExcluded = !!(excludedSet && excludedSet.has(abs));
                  const item = document.createElement('div');
                  item.style.cssText = 'position:relative;width:60px;height:60px;border:1px solid #333;border-radius:6px;overflow:hidden;';
                  const filterStyle = isManual ? 'none' : (isExcluded ? 'grayscale(1) opacity(0.4)' : 'none');
                  item.innerHTML = `
                    <img src="${abs}" alt="input" style="width:100%;height:100%;object-fit:cover;filter:${filterStyle};">
                    <button title="${isManual ? 'æ‰‹å‹•è¿½åŠ ã‚’è§£é™¤' : 'é™¤å¤–'}" style="position:absolute;top:2px;right:2px;background:#0008;color:#fff;border:none;border-radius:4px;cursor:pointer;padding:0 4px;">Ã—</button>
                  `;
                  const btn = item.querySelector('button');
                  btn.addEventListener('click', (e)=>{
                    e.preventDefault();
                    if (manualSet && manualSet.has(abs)) {
                      manualSet.delete(abs);
                      updateInputTray();
                      return;
                    }
                    if (window.__use_all_reference_images__) {
                      window.__input_exclude_set__.add(abs);
                      // å‚ç…§å´ã‚‚è¦–è¦šçš„ã«ãƒãƒ¼ã‚¯
                      const img = Array.from(qsa('#referenceGrid img')).find(x=>toAbsoluteUrl(x.src)===abs);
                      if (img && img.closest('.reference-item')) img.closest('.reference-item').classList.add('excluded');
                    } else {
                      // é¸æŠåˆ¶ã®å ´åˆã¯è©²å½“ã‚¢ã‚¤ãƒ†ãƒ ã®é¸æŠã‚’è§£é™¤
                      const img = Array.from(qsa('#referenceGrid .reference-item.selected img')).find(x=>toAbsoluteUrl(x.src)===abs);
                      if (img && img.closest('.reference-item')) img.closest('.reference-item').classList.remove('selected');
                    }
                    updateInputTray();
                  });
                  if (isManual) {
                    item.style.border = '1px solid #4a9eff';
                    item.style.boxShadow = '0 0 0 1px rgba(74,158,255,0.6)';
                    const badge = document.createElement('div');
                    badge.textContent = 'æ‰‹å‹•';
                    badge.style.cssText = 'position:absolute;left:4px;bottom:4px;background:rgba(74,158,255,0.85);color:#061018;font-size:10px;font-weight:600;padding:1px 4px;border-radius:4px;';
                    item.appendChild(badge);
                  }
                  tray.appendChild(item);
                });
                info.textContent = 'å¯¾è±¡: ' + urls.length + 'ä»¶';
              } catch(_){}
            }

            function extractAnyUrl(obj){
              try {
                if (!obj) return null;
                // æ–‡å­—åˆ—: ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…JSONâ†’URLã€ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¸­ã®URLã‚’æŠ½å‡º
                if (typeof obj === 'string') {
                  const s = String(obj);
                  // ```json ... ``` ã‚’å„ªå…ˆçš„ã«è§£æ
                  const m = s.match(/```(?:json)?\s*([\s\S]*?)```/i);
                  if (m && m[1]) {
                    try {
                      const j = JSON.parse(m[1]);
                      const u = extractAnyUrl(j);
                      if (u) return u;
                    } catch(_){}
                  }
                  // ãƒ†ã‚­ã‚¹ãƒˆä¸­ã®æœ€åˆã®URLï¼ˆç”»åƒæ‹¡å¼µå­ã‚’å„ªå…ˆï¼‰
                  const re = /https?:\/\/[^\s<>"'()]+/g;
                  const list = s.match(re);
                  if (list && list.length) {
                    const img = list.find(u => /\.(png|jpe?g|webp|gif|bmp|svg)(\?|#|$)/i.test(u));
                    return img || list[0];
                  }
                  return null;
                }
                // é…åˆ—
                if (Array.isArray(obj)) {
                  for (const it of obj){ const u = extractAnyUrl(it); if (u) return u; }
                  return null;
                }
                // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
                if (typeof obj === 'object') {
                  const keys = ['url','image_url','image','result_url','download_url','href'];
                  for (const k of keys){ if (obj && obj[k]){ const u = extractAnyUrl(obj[k]); if (u) return u; } }
                  // contenté…åˆ—({type:'text', text:'...'})ãªã©ã‚’èµ°æŸ»
                  if (obj && obj.content) {
                    const u = extractAnyUrl(obj.content);
                    if (u) return u;
                  }
                  for (const v of Object.values(obj)){ const u = extractAnyUrl(v); if (u) return u; }
                }
                return null;
              } catch(_) { return null; }
            }

            // ===== ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
            function ensureNanoLog(){
              const box = byId('nanoDebugBox');
              const pre = byId('nanoDebugLog');
              const btnCopy = byId('nanoLogCopy');
              const btnClear = byId('nanoLogClear');
              const auto = byId('nanoLogAutoscroll');
              if (!box || !pre) return;
              if (!box.dataset.ready){
                box.dataset.ready = '1';
                if (btnCopy) btnCopy.addEventListener('click', async ()=>{
                  try { await navigator.clipboard.writeText(pre.textContent||''); alert('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ'); } catch(_){}
                });
                if (btnClear) btnClear.addEventListener('click', ()=>{ if (window.clearNanoLogs) window.clearNanoLogs(); });
                // å¾©å…ƒ
                try { const saved = localStorage.getItem('nano-debug-log'); if (saved) { pre.textContent = saved; } } catch(_){ }
              }
            }
            // ãƒ­ã‚°å…¨æ¶ˆå»ï¼ˆUI/ä¿å­˜ã®ä¸¡æ–¹ï¼‰
            window.clearNanoLogs = function(){
              try {
                const pre = byId('nanoDebugLog');
                if (pre) pre.textContent = '';
                try { localStorage.removeItem('nano-debug-log'); } catch(_){}
                const dbg = byId('debugOutput');
                if (dbg) dbg.innerHTML = 'ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚';
              } catch(_){}
            };
            function nanoLog(msg){
              try {
                const pre = byId('nanoDebugLog');
                const auto = byId('nanoLogAutoscroll');
                if (!pre) return;
                const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
                pre.textContent += (pre.textContent? '\n' : '') + line;
                try { localStorage.setItem('nano-debug-log', pre.textContent); } catch(_){ }
                var dbgBox = byId('nanoDebugBox');
                if (dbgBox && dbgBox.open && auto && auto.checked) {
                  pre.scrollTop = pre.scrollHeight;
                }
              } catch(_){}
            }

            // ã‚µãƒ¼ãƒãƒ¼ãƒªã‚¹ãƒˆã®æ›´æ–°
            function updateServerList() {
                const serverList = byId('serverList');
                if (!serverList) return;

                const servers = mcpConfigManager.getServers();
                serverList.innerHTML = '';

                Object.entries(servers).forEach(([name, config]) => {
                    const serverItem = document.createElement('div');
                    serverItem.className = 'server-item';
                    serverItem.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div class="server-status" id="status-${name}"></div>
                            <div>
                                <div style="font-size: 13px; font-weight: 500;">${config.description || name}</div>
                                <div style="font-size: 11px; color: #888;">${config.url}</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button class="result-action-btn" onclick="testMcpConnection('${name}')" title="æ¥ç¶šãƒ†ã‚¹ãƒˆ">ğŸ”—</button>
                            <button class="result-action-btn" onclick="listMcpTools('${name}')" title="ãƒ„ãƒ¼ãƒ«ä¸€è¦§">ğŸ§°</button>
                            <button class="result-action-btn" onclick="removeMcpServer('${name}')" title="å‰Šé™¤">ğŸ—‘ï¸</button>
                        </div>
                    `;
                    serverList.appendChild(serverItem);
                });
            }

            // ã‚µãƒ¼ãƒãƒ¼ã®è¿½åŠ 
            const addServerBtn = byId('addServer');
            if (addServerBtn) {
                addServerBtn.addEventListener('click', function() {
                    const name = (byId('serverName')?.value || '').trim();
                    const url = (byId('serverUrl')?.value || '').trim();
                    const auth = (byId('serverAuth')?.value || '').trim();

                    if (!name || !url) {
                        alert('ã‚µãƒ¼ãƒãƒ¼åã¨URLã¯å¿…é ˆã§ã™');
                        return;
                    }

                    const serverConfig = {
                        url: url,
                        type: 'http',
                        description: name,
                        authorization: auth ? `Bearer ${auth}` : null
                    };

                    if (mcpConfigManager.addServer(name, serverConfig)) {
                        const nameInput = byId('serverName');
                        const urlInput = byId('serverUrl');
                        const authInput = byId('serverAuth');
                        if (nameInput) nameInput.value = '';
                        if (urlInput) urlInput.value = '';
                        if (authInput) authInput.value = '';
                        updateServerList();
                    } else {
                        alert('ã‚µãƒ¼ãƒãƒ¼ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                });
            }

            // ã‚µãƒ¼ãƒãƒ¼ã®å‰Šé™¤ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦ï¼‰
            window.removeMcpServer = function(name) {
                if (confirm(`ã‚µãƒ¼ãƒãƒ¼ "${name}" ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                    mcpConfigManager.removeServer(name);
                    updateServerList();
                }
            };

            // æ¥ç¶šãƒ†ã‚¹ãƒˆï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦ï¼‰
            window.testMcpConnection = async function(name) {
                debugLog(`ğŸ”— testMcpConnectioné–‹å§‹: ${name}`);
                const statusEl = byId(`status-${name}`);
                debugLog('statusEl:', statusEl ? 'è¦‹ã¤ã‹ã‚Šã¾ã—ãŸ' : 'è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                const config = mcpConfigManager.getServer(name);
                debugLog('ã‚µãƒ¼ãƒãƒ¼è¨­å®š:', config);

                if (!config) {
                    const msg = `MCPã‚µãƒ¼ãƒãƒ¼è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${name}`;
                    console.warn(msg);
                    if (statusEl) statusEl.classList.add('error');
                    alert(msg);
                    return;
                }

                statusEl.className = 'server-status';

                try {
                    // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLã«è‡ªå‹•å¤‰æ›
                    let testUrl = config.url;
                    const kamuiCodeUrl = window.KAMUI_CODE_URL;
                    const kamuiCodeRegex = new RegExp(`^https?://${kamuiCodeUrl}/`, 'i');
                    if (kamuiCodeRegex.test(testUrl)) {
                        const pathPart = testUrl.replace(kamuiCodeRegex, '');
                        testUrl = 'http://localhost:3001/mcp/' + pathPart;
                        debugLog(`ğŸ”„ URLå¤‰æ›: ${config.url} â†’ ${testUrl}`);
                    }

                    const client = new HttpMcpClient(testUrl, {
                        authorization: config.authorization,
                        clientName: 'kamui-web-client',
                        clientVersion: '1.0.0'
                    });
                    window.currentMcpClient = client;

                    debugLog('ğŸ”Œ æ¥ç¶šãƒ†ã‚¹ãƒˆé–‹å§‹...');
                    const result = await client.testConnection();
                    if (result.success) {
                        statusEl.classList.add('connected');
                        debugLog(`âœ… ${name} æ¥ç¶šæˆåŠŸ!`, result.serverInfo);
                    } else {
                        statusEl.classList.add('error');
                        const info = {
                          error: result.error,
                          server: config.url,
                          hasAuth: !!config.authorization,
                          sessionId: client.sessionId || null,
                          debug: (client.getDebugInfo ? client.getDebugInfo() : null),
                          advice: 'é–‹ç™ºç”¨ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLï¼ˆä¾‹: http://localhost:3001/mcp/...ï¼‰ã®åˆ©ç”¨ã‚’æ¨å¥¨'
                        };
                        debugLog(`âŒ ${name} æ¥ç¶šå¤±æ•—`, info);
                        const json = JSON.stringify(info, null, 2);
                        if (window.openJsonModal) { window.openJsonModal(json, 'æ¥ç¶šãƒ†ã‚¹ãƒˆ å¤±æ•—ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); }
                    }
                } catch (error) {
                    debugLog(`ğŸ’¥ ä¾‹å¤–ç™ºç”Ÿ in testMcpConnection`, {
                        error: error.message,
                        stack: error.stack
                    });
                    statusEl.classList.add('error');
                    const info = {
                      error: String((error && error.message)||error),
                      server: (mcpConfigManager.getServer(name)||{}).url,
                      hasAuth: !!(mcpConfigManager.getServer(name)||{}).authorization,
                      stack: error.stack || 'No stack trace'
                    };
                    console.error(`MCP server ${name} connection failed:`, info);
                    const json = JSON.stringify(info, null, 2);
                    if (window.openJsonModal) { window.openJsonModal(json, 'æ¥ç¶šãƒ†ã‚¹ãƒˆ ä¾‹å¤–ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); }
                    else { alert('æ¥ç¶šãƒ†ã‚¹ãƒˆä¾‹å¤–: ' + info.error); }
                }
            };

            // ãƒ„ãƒ¼ãƒ«ä¸€è¦§ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ï¼‰
            window.listMcpTools = async function(name){
                debugLog(`ğŸ§° ãƒ„ãƒ¼ãƒ«ä¸€è¦§å–å¾—é–‹å§‹: ${name}`);
                try {
                    const config = mcpConfigManager.getServer(name);
                    if (!config) {
                        const msg = `MCPã‚µãƒ¼ãƒãƒ¼è¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${name}`;
                        debugLog(`âŒ ${msg}`);
                        alert(msg);
                        return;
                    }
                    // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLã«è‡ªå‹•å¤‰æ›
                    let toolUrl = config.url;
                    const kamuiCodeUrl = window.KAMUI_CODE_URL;
                    const kamuiCodeRegex = new RegExp(`^https?://${kamuiCodeUrl}/`, 'i');
                    if (kamuiCodeRegex.test(toolUrl)) {
                        const pathPart = toolUrl.replace(kamuiCodeRegex, '');
                        toolUrl = 'http://localhost:3001/mcp/' + pathPart;
                        debugLog(`ğŸ”„ ãƒ„ãƒ¼ãƒ«ç”¨URLå¤‰æ›: ${config.url} â†’ ${toolUrl}`);
                    }

                    const client = new HttpMcpClient(toolUrl, {
                        authorization: config.authorization,
                        clientName: 'kamui-web-client',
                        clientVersion: '1.0.0'
                    });
                    window.currentMcpClient = client;
                    debugLog('ğŸ”§ ãƒ„ãƒ¼ãƒ«ç”¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...');
                    await client.initialize();
                    debugLog('ğŸ“‹ ãƒ„ãƒ¼ãƒ«ãƒªã‚¹ãƒˆå–å¾—ä¸­...');
                    const tools = await client.listTools();
                    debugLog('ğŸ“‹ ãƒ„ãƒ¼ãƒ«ãƒªã‚¹ãƒˆå–å¾—å®Œäº†:', tools);
                    const payload = (tools && tools.result) || tools;
                    const json = JSON.stringify(payload, null, 2);
                    if (window.openJsonModal) { window.openJsonModal(json, 'åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«'); }
                    else { alert('åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«:\n' + json); }
                } catch(err){
                    debugLog('ğŸ’¥ ãƒ„ãƒ¼ãƒ«ä¸€è¦§å–å¾—å¤±æ•—', {
                        error: err.message,
                        stack: err.stack
                    });
                    const info = {
                      error: String((err && err.message)||err),
                      hint: 'ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯è‡ªå‹•å†åˆæœŸåŒ–ã—å†è©¦è¡Œæ¸ˆã¿',
                      server: (mcpConfigManager.getServer(name)||{}).url,
                      hasAuth: !!(mcpConfigManager.getServer(name)||{}).authorization,
                      sessionId: ((window.currentMcpClient && window.currentMcpClient.sessionId)||null),
                      debug: ((window.currentMcpClient && window.currentMcpClient.getDebugInfo ? window.currentMcpClient.getDebugInfo() : null)),
                      advice: 'ãƒ—ãƒ­ã‚­ã‚·çµŒç”±URLï¼ˆhttp://localhost:3001/mcp/...ï¼‰ã®åˆ©ç”¨ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ mcp-session-id ã®æœ‰ç„¡ç¢ºèª'
                    };
                    const json = JSON.stringify(info, null, 2);
                    console.error('listTools failed', info);
                    if (window.openJsonModal) { window.openJsonModal(json, 'ãƒ„ãƒ¼ãƒ«ä¸€è¦§ å–å¾—ã‚¨ãƒ©ãƒ¼ï¼ˆã‚³ãƒ”ãƒ¼å¯ï¼‰'); }
                    else { alert('ãƒ„ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:\n' + json); }
                }
            };

            // ç”»åƒç”Ÿæˆï¼ˆæœªä½¿ç”¨UIï¼‰ã¯å‰Šé™¤æ¸ˆã¿

            // ç”Ÿæˆç”»åƒã‚’çµæœã‚°ãƒªãƒƒãƒ‰ã«è¿½åŠ 
            function addGeneratedImage(imageUrl, prompt) {
                const resultGrid = byId('resultGrid');
                if (!resultGrid) return;

                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.innerHTML = `
                    <img src="${imageUrl}" alt="${prompt}" loading="lazy">
                    <div class="result-actions">
                        <button class="result-action-btn" onclick="useAsReference('${imageUrl}')" title="ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã¨ã—ã¦ä½¿ç”¨">ğŸ“Œ</button>
                        <button class="result-action-btn" onclick="downloadImage('${imageUrl}')" title="ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">ğŸ’¾</button>
                    </div>
                `;

                // ç”»åƒã‚¯ãƒªãƒƒã‚¯ã§ Before ã‚¨ãƒªã‚¢ã«è¨­å®š
                resultItem.addEventListener('click', function() {
                    const beforeImg = qs('#beforeImage img');
                    if (beforeImg) {
                        beforeImg.src = imageUrl;
                        beforeImg.alt = prompt;
                    }
                });

                resultGrid.insertBefore(resultItem, resultGrid.firstChild);
                // Afterãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å³æ™‚æ›´æ–°
                setAfterImage(imageUrl);
            }

            // ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã¨ã—ã¦ä½¿ç”¨ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ï¼‰
            window.useAsReference = function(imageUrl) {
                const beforeImg = qs('#beforeImage img');
                if (beforeImg) {
                    beforeImg.src = imageUrl;
                    beforeImg.alt = 'Generated reference';
                }
            };

            function setAfterImage(url){
                const after = byId('afterImage');
                if (!after) return;
                after.innerHTML = `<img src="${url}" alt="Generated result" crossorigin="anonymous" style="width: 100%; height: 100%; object-fit: contain;">`;
            }

            async function localGenerateFromBefore({ prompt, model, size }){
                // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ­ãƒ¼ã‚«ãƒ«æ“¬ä¼¼ç”Ÿæˆ: Beforeç”»åƒã«è‰²èª¿ãƒ•ã‚£ãƒ«ã‚¿ã¨é€ã‹ã—ã‚’é©ç”¨
                const beforeImg = qs('#beforeImage img');
                if (!beforeImg) throw new Error('Beforeç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                await new Promise(r => { if (beforeImg.complete) r(); else beforeImg.onload = r; });
                const [w,h] = (size||'1024x1024').split('x').map(n=>parseInt(n,10)||512);
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                const ctx = c.getContext('2d');
                // draw base
                ctx.drawImage(beforeImg, 0, 0, w, h);
                // tint by model
                const tints = { 'flux-ultra':'#00d4aa', 'flux-pro':'#4a9eff', 'midjourney':'#a855f7' };
                ctx.fillStyle = (tints[model]||'#4a9eff') + '55';
                ctx.fillRect(0,0,w,h);
                // add prompt watermark
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.fillRect(0,h-64,w,64);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px system-ui, sans-serif';
                const text = (prompt||'').slice(0,120);
                ctx.fillText(text, 16, h-24);
                return c.toDataURL('image/png');
            }

            // ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ï¼‰
            window.downloadImage = function(imageUrl) {
                const link = document.createElement('a');
                link.href = imageUrl;
                link.download = `generated-image-${Date.now()}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            // MCPåˆæœŸåŒ–
            initializeMcpConfig();

            // Function to load images into reference grid
            function loadImages() {
                const referenceGrid = byId('referenceGrid');
                referenceGrid.innerHTML = ''; // Clear existing images

                allImages.forEach((imageName, index) => {
                    const referenceItem = document.createElement('div');
                    referenceItem.className = 'reference-item';

                    // Select first few items by default for demo
                    if (index % 3 === 0) {
                        referenceItem.classList.add('selected');
                    }

                    // Create readable alt text from filename
                    const altText = imageName
                        .replace(/\.(png|jpg|jpeg|gif)$/i, '')
                        .replace(/[-_]/g, ' ')
                        .replace(/\b\w/g, char => char.toUpperCase());

                    // /images ä»¥ä¸‹ã®è‡ªå‹•è¡¨ç¤ºã¯å»ƒæ­¢
                    referenceItem.innerHTML = `
                        <img src="" alt="${altText}">
                        <div class="checkmark">âœ“</div>
                    `;

                    referenceGrid.appendChild(referenceItem);
                });

                // Re-attach click event listeners
                qsa('.reference-item').forEach(item => {
                    // Left click - update Before image
                    item.addEventListener('click', function(e) {
                        e.preventDefault();

                        // Toggle selection
                        this.classList.toggle('selected');

                        // Update Before image
                        const img = this.querySelector('img');
                        if (img) {
                            const beforeImg = qs('#beforeImage img');
                            if (beforeImg) {
                                beforeImg.src = img.src;
                                beforeImg.alt = img.alt;
                            }
                        }
                        updateInputTray();
                    });

                    // Right click - show context menu with relative path
                    item.addEventListener('contextmenu', function(e) {
                        e.preventDefault();

                        const img = this.querySelector('img');
                        if (img) {
                            // ãã®ã¾ã¾ã®URLã‚’è¡¨ç¤ºï¼ˆ/images ãªã©ã®ç›¸å¯¾åŒ–ã¯è¡Œã‚ãªã„ï¼‰
                            const src = img.src;
                            const relativePath = src;

                            // Remove existing context menu if any
                            const existingMenu = document.querySelector('.context-menu');
                            if (existingMenu) {
                                existingMenu.remove();
                            }

                            // Create context menu
                            const menu = document.createElement('div');
                            menu.className = 'context-menu';
                            menu.style.cssText = `
                                position: fixed;
                                left: ${e.clientX}px;
                                top: ${e.clientY}px;
                                background: #2a2a2a;
                                border: 1px solid #444;
                                border-radius: 4px;
                                padding: 8px 12px;
                                color: #e0e0e0;
                                font-size: 12px;
                                z-index: 1000;
                                cursor: pointer;
                                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                            `;
                            menu.textContent = relativePath;
                            menu.title = 'Click to copy';

                            // Copy on click
                            menu.addEventListener('click', function() {
                                navigator.clipboard.writeText(relativePath).then(() => {
                                    menu.textContent = 'âœ… Copied!';
                                    setTimeout(() => {
                                        menu.remove();
                                    }, 1000);
                                }).catch(err => {
                                    console.error('Failed to copy:', err);
                                    menu.textContent = 'âŒ Copy failed';
                                });
                            });

                            document.body.appendChild(menu);

                            // Remove menu when clicking elsewhere
                            const removeMenu = (e) => {
                                if (!menu.contains(e.target)) {
                                    menu.remove();
                                    document.removeEventListener('click', removeMenu);
                                }
                            };
                            setTimeout(() => {
                                document.addEventListener('click', removeMenu);
                            }, 0);
                        }
                    });
                });
                updateInputTray();
            }

            // /images ä»¥ä¸‹ã®ä¸€æ‹¬è¡¨ç¤ºãƒ»èª­ã¿è¾¼ã¿ã¯å»ƒæ­¢ï¼ˆã‚®ãƒ£ãƒ©ãƒªãƒ¼/å¤–éƒ¨URL/ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ ã®ã¿ã‚’ä½¿ç”¨ï¼‰

            // Drawing functionality
            const canvas = byId('drawingCanvas');
            const ctx = canvas ? canvas.getContext('2d') : null;
            if (canvas && ctx) {
                let isDrawing = false;
                let drawingEnabled = false;
                let textMode = false;
                let lastSavedDrawing = null;
                let eraserEnabled = false;
                let isErasing = false;
                let currentPenColor = '#ff0000';
                let currentPenSize = 3;
                let currentTextSize = 24;
                let currentEraserSize = 40;
                let canvasSnapshotUrl = null;

                const toggleDrawBtn = byId('toggleDraw');
                const clearCanvasBtn = byId('clearCanvas');
                const switchImagesBtn = byId('switchImages');
                const saveDrawingBtn = byId('saveDrawing');
                const penColorInput = byId('penColor');
                const penSizeInput = byId('penSize');
                const penSizeLabel = byId('penSizeLabel');
                const textInput = byId('textInput');
                const textSizeInput = byId('textSize');
                const textSizeLabel = byId('textSizeLabel');
                const placeTextBtn = byId('placeTextBtn');
                const eraserSizeInput = byId('eraserSize');
                const eraserSizeLabel = byId('eraserSizeLabel');
                const toggleEraserBtn = byId('toggleEraser');

                const rememberCanvas = () => {
                    try {
                        if (canvas.width > 0 && canvas.height > 0) {
                            canvasSnapshotUrl = canvas.toDataURL('image/png');
                        }
                    } catch (_) { /* ignore */ }
                };

                const restoreCanvas = (snapshot) => {
                    if (!snapshot) return;
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        rememberCanvas();
                    };
                    img.src = snapshot;
                };

                const updatePenSizeLabel = (value) => {
                    if (penSizeLabel) penSizeLabel.textContent = value + ' px';
                };

                const updateTextSizeLabel = (value) => {
                    if (textSizeLabel) textSizeLabel.textContent = value + ' px';
                };

                const updateEraserSizeLabel = (value) => {
                    if (eraserSizeLabel) eraserSizeLabel.textContent = value + ' px';
                };

                const applyDrawingStyles = () => {
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.strokeStyle = currentPenColor;
                    ctx.lineWidth = currentPenSize;
                };

                const syncCanvasVisibility = () => {
                    canvas.style.display = (drawingEnabled || textMode || eraserEnabled) ? 'block' : 'none';
                };

                const setCanvasCursor = () => {
                    if (textMode) {
                        canvas.style.cursor = 'text';
                    } else if (eraserEnabled) {
                        canvas.style.cursor = 'cell';
                    } else if (drawingEnabled) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                };

                const resizeCanvasToImage = () => {
                    const imgEl = qs('#beforeImage img');
                    const container = byId('beforeImage');
                    if (!imgEl || !container || !imgEl.complete || !imgEl.naturalWidth) return;

                    // Preserve drawing if it exists
                    const snapshot = (canvas.width > 0 && canvas.height > 0) ? canvas.toDataURL('image/png') : null;

                    // Set canvas resolution to the image's natural resolution
                    canvas.width = imgEl.naturalWidth;
                    canvas.height = imgEl.naturalHeight;

                    // Calculate the visual dimensions and position of the image (due to object-fit: contain)
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    const imageRatio = imgEl.naturalWidth / imgEl.naturalHeight;
                    const containerRatio = containerWidth / containerHeight;

                    let visualWidth, visualHeight, top, left;

                    if (containerRatio > imageRatio) {
                        // Container is wider than image (letterboxed)
                        visualHeight = containerHeight;
                        visualWidth = visualHeight * imageRatio;
                        top = 0;
                        left = (containerWidth - visualWidth) / 2;
                    } else {
                        // Container is taller than image (pillarboxed)
                        visualWidth = containerWidth;
                        visualHeight = visualWidth / imageRatio;
                        top = (containerHeight - visualHeight) / 2;
                        left = 0;
                    }

                    // Apply styles to perfectly overlay the canvas on the image
                    canvas.style.width = visualWidth + 'px';
                    canvas.style.height = visualHeight + 'px';
                    canvas.style.top = top + 'px';
                    canvas.style.left = left + 'px';

                    // Restore drawing styles and content
                    applyDrawingStyles();
                    if (snapshot) {
                        restoreCanvas(snapshot);
                    } else {
                        rememberCanvas();
                    }
                };

                const exitTextMode = () => {
                    textMode = false;
                    if (placeTextBtn) {
                        placeTextBtn.classList.remove('active');
                        placeTextBtn.textContent = 'ğŸ…£ ãƒ†ã‚­ã‚¹ãƒˆé…ç½®';
                    }
                };

                const exitEraserMode = () => {
                    eraserEnabled = false;
                    isErasing = false;
                    if (toggleEraserBtn) {
                        toggleEraserBtn.classList.remove('active');
                        toggleEraserBtn.textContent = 'ğŸ§½ Eraser';
                        toggleEraserBtn.style.background = '#3a3a3a';
                    }
                };

                const getPos = (src) => {
                    const rect = canvas.getBoundingClientRect();
                    let point = src;
                    if (src.touches && src.touches.length) {
                        point = src.touches[0];
                    }
                    return {
                        x: ((point.clientX - rect.left) / rect.width) * canvas.width,
                        y: ((point.clientY - rect.top) / rect.height) * canvas.height
                    };
                };

                const placeTextAt = (evt) => {
                    const text = textInput ? textInput.value.trim() : '';
                    if (!text) {
                        if (textInput) textInput.focus();
                        return;
                    }
                    const pos = getPos(evt);
                    ctx.save();
                    ctx.fillStyle = currentPenColor;
                    ctx.font = `${currentTextSize}px "Segoe UI", Helvetica, Arial, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, pos.x, pos.y);
                    ctx.restore();
                    rememberCanvas();
                };

                updatePenSizeLabel(currentPenSize);
                updateTextSizeLabel(currentTextSize);
                updateEraserSizeLabel(currentEraserSize);
                applyDrawingStyles();
                syncCanvasVisibility();
                setCanvasCursor();
                rememberCanvas();

                if (penColorInput) {
                    penColorInput.addEventListener('input', (event) => {
                        currentPenColor = event.target.value;
                        applyDrawingStyles();
                    });
                }

                if (penSizeInput) {
                    penSizeInput.addEventListener('input', (event) => {
                        currentPenSize = Math.max(1, Number(event.target.value) || 1);
                        updatePenSizeLabel(currentPenSize);
                        applyDrawingStyles();
                    });
                }

                if (textSizeInput) {
                    textSizeInput.addEventListener('input', (event) => {
                        currentTextSize = Math.max(8, Number(event.target.value) || 24);
                        updateTextSizeLabel(currentTextSize);
                    });
                }

                if (eraserSizeInput) {
                    eraserSizeInput.addEventListener('input', (event) => {
                        currentEraserSize = Math.max(8, Number(event.target.value) || 40);
                        updateEraserSizeLabel(currentEraserSize);
                    });
                }

                if (toggleDrawBtn) {
                    toggleDrawBtn.addEventListener('click', () => {
                        drawingEnabled = !drawingEnabled;
                        if (drawingEnabled) {
                            exitTextMode();
                            exitEraserMode();
                            setTimeout(resizeCanvasToImage, 0);
                        }
                        toggleDrawBtn.textContent = drawingEnabled ? 'ğŸ–Šï¸ Drawing' : 'âœï¸ Draw';
                        toggleDrawBtn.style.background = drawingEnabled ? '#4a9eff' : '#3a3a3a';
                        toggleDrawBtn.classList.toggle('active', drawingEnabled);
                        syncCanvasVisibility();
                        setCanvasCursor();
                    });
                }

                if (toggleEraserBtn) {
                    toggleEraserBtn.addEventListener('click', () => {
                        eraserEnabled = !eraserEnabled;
                        if (eraserEnabled) {
                            drawingEnabled = false;
                            exitTextMode();
                            if (toggleDrawBtn) {
                                toggleDrawBtn.textContent = 'âœï¸ Draw';
                                toggleDrawBtn.style.background = '#3a3a3a';
                                toggleDrawBtn.classList.remove('active');
                            }
                            setTimeout(resizeCanvasToImage, 0);
                        } else {
                            isErasing = false;
                        }
                        toggleEraserBtn.classList.toggle('active', eraserEnabled);
                        toggleEraserBtn.textContent = eraserEnabled ? 'ğŸ§½ Erasing' : 'ğŸ§½ Eraser';
                        toggleEraserBtn.style.background = eraserEnabled ? '#4a9eff' : '#3a3a3a';
                        syncCanvasVisibility();
                        setCanvasCursor();
                    });
                }

                if (placeTextBtn) {
                    placeTextBtn.addEventListener('click', () => {
                        textMode = !textMode;
                        if (textMode) {
                            drawingEnabled = false;
                            exitEraserMode();
                            if (toggleDrawBtn) {
                                toggleDrawBtn.textContent = 'âœï¸ Draw';
                                toggleDrawBtn.style.background = '#3a3a3a';
                                toggleDrawBtn.classList.remove('active');
                            }
                            setTimeout(resizeCanvasToImage, 0);
                        }
                        placeTextBtn.classList.toggle('active', textMode);
                        placeTextBtn.textContent = textMode ? 'ğŸ…£ ãƒ†ã‚­ã‚¹ãƒˆé…ç½®ä¸­' : 'ğŸ…£ ãƒ†ã‚­ã‚¹ãƒˆé…ç½®';
                        syncCanvasVisibility();
                        setCanvasCursor();
                    });
                }

                if (clearCanvasBtn) {
                    clearCanvasBtn.addEventListener('click', () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        rememberCanvas();
                    });
                }

                if (switchImagesBtn) {
                    switchImagesBtn.addEventListener('click', () => {
                        const beforeImg = qs('#beforeImage img');
                        const afterImg = qs('#afterImage img');
                        if (!beforeImg || !afterImg) return;
                        const tempSrc = beforeImg.src;
                        const tempAlt = beforeImg.alt;
                        beforeImg.src = afterImg.src;
                        beforeImg.alt = afterImg.alt;
                        afterImg.src = tempSrc;
                        afterImg.alt = tempAlt;
                    });
                }

                if (saveDrawingBtn) {
                    saveDrawingBtn.addEventListener('click', () => {
                        const beforeImg = qs('#beforeImage img');
                        if (!beforeImg || !beforeImg.complete || !beforeImg.naturalWidth) {
                            alert('èƒŒæ™¯ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                            return;
                        }

                        const combinedCanvas = document.createElement('canvas');
                        const combinedCtx = combinedCanvas.getContext('2d');

                        // Set the final canvas to the natural, full resolution of the image
                        combinedCanvas.width = beforeImg.naturalWidth;
                        combinedCanvas.height = beforeImg.naturalHeight;

                        // Draw the original image without any scaling
                        combinedCtx.drawImage(beforeImg, 0, 0, beforeImg.naturalWidth, beforeImg.naturalHeight);

                        // Draw the drawing canvas on top. Since `drawingCanvas` has the same dimensions, this is a 1:1 copy.
                        combinedCtx.drawImage(canvas, 0, 0, beforeImg.naturalWidth, beforeImg.naturalHeight);

                        const dataURL = combinedCanvas.toDataURL('image/png');
                        const timestamp = Date.now();
                        const filename = 'hand-drawn-' + timestamp + '.png';

                        const referenceGrid = qs('.reference-grid');
                        if (referenceGrid) {
                            const newReferenceItem = document.createElement('div');
                            newReferenceItem.className = 'reference-item selected';
                            newReferenceItem.innerHTML = `
                                <img src="${dataURL}" alt="Hand Drawn">
                                <div class="checkmark">âœ“</div>
                            `;

                            newReferenceItem.addEventListener('click', function(e) {
                                e.preventDefault();
                                this.classList.toggle('selected');
                                const imgEl = this.querySelector('img');
                                if (imgEl) {
                                    const before = qs('#beforeImage img');
                                    if (before) {
                                        before.src = imgEl.src;
                                        before.alt = imgEl.alt;
                                    }
                                }
                            });

                            newReferenceItem.addEventListener('contextmenu', function(e) {
                                e.preventDefault();
                                const relativePath = '/' + filename;
                                const existingMenu = document.querySelector('.context-menu');
                                if (existingMenu) existingMenu.remove();

                                const menu = document.createElement('div');
                                menu.className = 'context-menu';
                                menu.style.cssText = `
                                    position: fixed;
                                    left: ${e.clientX}px;
                                    top: ${e.clientY}px;
                                    background: #2a2a2a;
                                    border: 1px solid #444;
                                    border-radius: 4px;
                                    padding: 8px 12px;
                                    color: #e0e0e0;
                                    font-size: 12px;
                                    z-index: 1000;
                                    cursor: pointer;
                                    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                                `;
                                menu.textContent = relativePath;
                                menu.title = 'Click to copy';

                                menu.addEventListener('click', function() {
                                    navigator.clipboard.writeText(relativePath).then(() => {
                                        menu.textContent = 'âœ… Copied!';
                                        setTimeout(() => menu.remove(), 1000);
                                    }).catch(err => {
                                        console.error('Failed to copy:', err);
                                        menu.textContent = 'âŒ Copy failed';
                                    });
                                });

                                document.body.appendChild(menu);
                                const removeMenu = (evt) => {
                                    if (!menu.contains(evt.target)) {
                                        menu.remove();
                                        document.removeEventListener('click', removeMenu);
                                    }
                                };
                                setTimeout(() => document.addEventListener('click', removeMenu), 0);
                            });

                            referenceGrid.appendChild(newReferenceItem);
                        }

                        lastSavedDrawing = dataURL;

                        combinedCanvas.toBlob(function(blob) {
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = filename;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, 'image/png');

                        const originalText = saveDrawingBtn.textContent;
                        saveDrawingBtn.textContent = 'âœ… Saved & Added!';
                        saveDrawingBtn.style.background = '#4CAF50';
                        setTimeout(() => {
                            saveDrawingBtn.textContent = originalText;
                            saveDrawingBtn.style.background = '#3a3a3a';
                        }, 2000);
                    });
                }

                const beforeImgEl = qs('#beforeImage img');
                if (beforeImgEl) {
                    beforeImgEl.addEventListener('load', () => {
                        // When a new image is loaded, resize the canvas if drawing is active
                        if (drawingEnabled || textMode || eraserEnabled) {
                            resizeCanvasToImage();
                        }
                    });
                }

                window.addEventListener('resize', () => {
                    if (drawingEnabled || textMode || eraserEnabled) {
                        resizeCanvasToImage();
                    }
                });

                canvas.addEventListener('pointerdown', (e) => {
                    if (textMode) {
                        placeTextAt(e);
                        return;
                    }
                    if (!drawingEnabled && !eraserEnabled) return;
                    isDrawing = true;
                    isErasing = eraserEnabled;
                    try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
                    const pos = getPos(e);
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    if (isErasing) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.lineWidth = currentEraserSize;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        ctx.restore();
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                    }
                    e.preventDefault();
                });

                canvas.addEventListener('pointermove', (e) => {
                    if (!isDrawing) return;
                    const pos = getPos(e);
                    if (isErasing) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.lineWidth = currentEraserSize;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        ctx.restore();
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                    } else if (drawingEnabled) {
                        ctx.strokeStyle = currentPenColor;
                        ctx.lineWidth = currentPenSize;
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                    e.preventDefault();
                });

                const stopDraw = (e) => {
                    if (!isDrawing) return;
                    isDrawing = false;
                    isErasing = false;
                    try { canvas.releasePointerCapture(e.pointerId); } catch (_) {}
                    rememberCanvas();
                };

                canvas.addEventListener('pointerup', stopDraw);
                canvas.addEventListener('pointercancel', stopDraw);
                canvas.addEventListener('pointerleave', stopDraw);

                if (!('onpointerdown' in window)) {
                    const opts = { passive: false };
                    canvas.addEventListener('touchstart', (e) => {
                        if (textMode) {
                            placeTextAt(e);
                            e.preventDefault();
                            return;
                        }
                        if (!drawingEnabled && !eraserEnabled) return;
                        isDrawing = true;
                        isErasing = eraserEnabled;
                        ctx.beginPath();
                        const pos = getPos(e);
                        ctx.moveTo(pos.x, pos.y);
                        if (isErasing) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-out';
                            ctx.lineWidth = currentEraserSize;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.lineTo(pos.x, pos.y);
                            ctx.stroke();
                            ctx.restore();
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                        }
                        e.preventDefault();
                    }, opts);
                    canvas.addEventListener('touchmove', (e) => {
                        if (!isDrawing) return;
                        const pos = getPos(e);
                        if (isErasing) {
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-out';
                            ctx.lineWidth = currentEraserSize;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            ctx.lineTo(pos.x, pos.y);
                            ctx.stroke();
                            ctx.restore();
                            ctx.beginPath();
                            ctx.moveTo(pos.x, pos.y);
                        } else if (drawingEnabled) {
                            ctx.strokeStyle = currentPenColor;
                            ctx.lineWidth = currentPenSize;
                            ctx.lineTo(pos.x, pos.y);
                            ctx.stroke();
                        }
                        e.preventDefault();
                    }, opts);
                    const end = () => {
                        if (!isDrawing) return;
                        isDrawing = false;
                        isErasing = false;
                        rememberCanvas();
                    };
                    canvas.addEventListener('touchend', end);
                    canvas.addEventListener('touchcancel', end);
                }
            }

        // ===== ã‚¹ãƒãƒ›ç”¨ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºæ©Ÿèƒ½ =====
        function debugLog(message, data = null) {
            const debugOutput = byId('debugOutput');
            if (!debugOutput) return;

            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `[${timestamp}] ${message}`;
            if (data !== null) {
                logEntry += '\n' + JSON.stringify(data, null, 2);
            }

            // æ—¢å­˜ã®ãƒ­ã‚°ã«è¿½åŠ 
            const currentContent = debugOutput.innerHTML;
            const cc = (currentContent || '').replace(/\s+/g, ' ').trim();
            if (cc === '' || cc.includes('ãƒ‡ãƒãƒƒã‚°æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™') || cc.includes('ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ')) {
                debugOutput.innerHTML = logEntry;
            } else {
                debugOutput.innerHTML = currentContent + '\n\n' + logEntry;
            }

            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ä¸‹ã«ç§»å‹•
            debugOutput.scrollTop = debugOutput.scrollHeight;
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹
        window.debugLog = debugLog;

        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
        window.addEventListener('error', function(event) {
            debugLog('âŒ JavaScript Error:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error ? event.error.stack : 'No stack trace'
            });
        });

        window.addEventListener('unhandledrejection', function(event) {
            debugLog('âŒ Unhandled Promise Rejection:', {
                reason: event.reason,
                promise: event.promise
            });
        });
    });
    </script>
