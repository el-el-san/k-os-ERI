# Directory Graph 3D
# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’3Dãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§å¯è¦–åŒ–

- id: directory-graph-3d
  category: 1
  category_name: 3Dã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
  title: Directory Graph 3D
  content: ""
  custom_html: |
    <script>
      // THREEã‚’å…ˆã«èª­ã¿è¾¼ã‚€ï¼ˆæœªãƒ­ãƒ¼ãƒ‰æ™‚ã®ã¿ï¼‰
      if (!window.THREE) {
        const threeScript = document.createElement('script');
        threeScript.src = '//cdn.jsdelivr.net/npm/three@0.158/build/three.min.js';
        document.head.appendChild(threeScript);
      }
      // 3D Force Graphã‚’ä¸€åº¦ã ã‘èª­ã¿è¾¼ã‚€
      if (!window.ForceGraph3DLoaded) {
        const script = document.createElement('script');
        script.src = '//cdn.jsdelivr.net/npm/3d-force-graph';
        script.onload = () => {
          window.ForceGraph3DLoaded = true;
          console.log('3D Force Graph loaded');
        };
        document.head.appendChild(script);
      }
      // ARButton (WebXR) ã‚’èª­ã¿è¾¼ã‚€
      if (!(window.ARButton || (window.THREE && window.THREE.ARButton))) {
        const arScript = document.createElement('script');
        arScript.src = '//cdn.jsdelivr.net/npm/three@0.158/examples/js/webxr/ARButton.js';
        arScript.onload = () => { window.__ARButtonLoaded = true; };
        document.head.appendChild(arScript);
      }
    </script>
    
    <style>
      body { margin: 0; }
      .directory-graph-container {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 20px;
      }
      .directory-graph-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text);
        margin-bottom: 16px;
        text-align: center;
      }
      .directory-graph-main {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 320px;
        gap: 20px;
        align-items: start;
      }
      .directory-graph-canvas-container {
        flex: 1 1 70%;
        height: 600px;
        min-height: 600px;
        background: #000003;
        border: 1px solid var(--border);
        border-radius: 8px;
        position: relative;
        min-width: 0;
        overflow: hidden;
      }
      #directory-graph-3d-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .directory-graph-info {
        flex: 0 0 28%;
        color: var(--text);
        font-size: 0.9rem;
        padding: 16px;
        background: var(--sidebar-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
      }
      .directory-graph-info h3 {
        color: var(--link);
        margin: 0 0 12px 0;
        font-size: 1.05rem;
      }
      .directory-graph-info ul {
        margin: 0 0 8px 18px;
      }
      .directory-graph-info li {
        margin-bottom: 6px;
        line-height: 1.5;
      }
      .view-toggle {
        margin-top: 12px;
        display: flex;
        gap: 8px;
      }
      .info-toggle {
        margin-top: 16px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .toggle-btn {
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        cursor: pointer;
      }
      .toggle-btn.active {
        background: var(--link);
        color: #fff;
      }
      .info-btn {
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        cursor: pointer;
        font-size: 0.82rem;
        transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
      }
      .info-btn:hover {
        border-color: var(--link);
        color: var(--link);
      }
      .info-btn.active {
        background: var(--link);
        color: #fff;
        border-color: color-mix(in srgb, var(--link) 65%, #ffffff 35%);
      }
      .info-sections {
        margin-top: 16px;
      }
      .info-section {
        display: none;
      }
      .info-section.active {
        display: block;
      }
      .info-heading {
        margin: 0 0 12px 0;
        font-size: 1.05rem;
        color: var(--link);
      }
      .directory-stats {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border);
      }
      .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }
      .stat-label {
        color: var(--text-muted);
      }
      .stat-value {
        font-weight: 600;
        color: var(--link);
      }
      @media (max-width: 900px) {
        .directory-graph-main {
          grid-template-columns: 1fr;
        }
        .directory-graph-canvas-container {
          height: 420px;
        }
        .directory-graph-info {
          width: 100%;
        }
      }
      .directory-graph-description {
        color: var(--text);
        line-height: 1.6;
        margin-bottom: 16px;
      }
      .loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ffffff;
        font-size: 1.2rem;
      }
      /* ãƒãƒ¼ãƒ‰ã®å‡¡ä¾‹ */
      .node-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 12px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }
      .legend-label {
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .node-preview {
        margin-top: 18px;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.08);
        background: linear-gradient(160deg, rgba(15,23,42,0.65), rgba(15,23,42,0.35));
        backdrop-filter: blur(6px);
        box-shadow: 0 18px 40px rgba(15,23,42,0.45);
      }

      .node-preview h3 {
        margin: 0 0 10px 0;
        font-size: 1rem;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .node-preview-meta {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 4px;
        font-size: 0.82rem;
        color: var(--text-muted);
        margin-bottom: 10px;
      }

      .node-preview-meta .meta-label {
        display: inline-block;
        min-width: 48px;
        color: var(--text-weak);
        margin-right: 6px;
      }

      .node-preview-meta code {
        font-size: 0.78rem;
        background: rgba(255,255,255,0.04);
        padding: 2px 6px;
        border-radius: 4px;
      }

      .node-preview-body {
        min-height: 180px;
        max-height: 340px;
        overflow: auto;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(15,23,42,0.55);
        padding: 10px;
        position: relative;
      }

      .node-preview-body img,
      .node-preview-body video {
        max-width: 100%;
        border-radius: 6px;
        display: block;
      }

      .node-preview-body video,
      .node-preview-body audio {
        width: 100%;
      }

      .node-preview-body pre {
        margin: 0;
        font-size: 0.78rem;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        color: #e2e8f0;
        background: rgba(15,23,42,0.75);
        border-radius: 6px;
        padding: 10px;
      }

      .node-preview-body .preview-placeholder {
        color: var(--text-muted);
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
      }

      .node-preview-body .preview-section {
        margin-bottom: 10px;
      }

      .node-preview-body .preview-section:last-child {
        margin-bottom: 0;
      }

      .node-preview-body .preview-heading {
        font-size: 0.75rem;
        color: rgba(255,255,255,0.6);
        letter-spacing: 0.03em;
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .node-preview-body ul {
        margin: 0;
        padding-left: 18px;
        font-size: 0.82rem;
      }

      .node-preview-body li {
        color: rgba(226,232,240,0.85);
        margin-bottom: 2px;
      }

      .node-preview-body .preview-note {
        margin-top: 4px;
        font-size: 0.75rem;
        color: rgba(255,255,255,0.45);
      }
    </style>
    
    <div class="directory-graph-container">
      <h2 class="directory-graph-title">Directory Graph 3D</h2>
      
      <div class="directory-graph-description">
        SCAN_PATHé…ä¸‹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’3Dç©ºé–“ã§å¯è¦–åŒ–ã€‚ãƒ•ã‚©ãƒ«ãƒ€ã¨ãƒ•ã‚¡ã‚¤ãƒ«ã®é–¢ä¿‚æ€§ã‚’
        ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«æ¢ç´¢ã§ãã¾ã™ã€‚
      </div>
      
      <div class="directory-graph-main">
        <div class="directory-graph-canvas-container">
          <div id="directory-graph-3d-canvas">
            <div class="loading-message">ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
          </div>
        </div>
        
      <div class="directory-graph-info">
          <div class="view-toggle">
            <button type="button" class="toggle-btn" id="toggle-color-mode">è‰²ã§è¡¨ç¤º</button>
            <button type="button" class="toggle-btn active" id="toggle-media-mode">ãƒ¡ãƒ‡ã‚£ã‚¢ã§è¡¨ç¤º</button>
          </div>

          <div class="info-toggle">
            <button type="button" class="info-btn active" data-target="preview" aria-pressed="true">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
            <button type="button" class="info-btn" data-target="controls" aria-pressed="false">æ“ä½œæ–¹æ³•</button>
            <button type="button" class="info-btn" data-target="stats" aria-pressed="false">çµ±è¨ˆæƒ…å ±</button>
          </div>

          <div class="info-sections">
            <div class="info-section active" data-section="preview">
              <div class="node-preview">
                <h3>
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="2" x2="12" y2="6"></line>
                    <line x1="12" y1="18" x2="12" y2="22"></line>
                    <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                    <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                  </svg>
                  ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                </h3>
                <div class="node-preview-meta">
                  <div><span class="meta-label">åå‰</span><span id="node-preview-name">-</span></div>
                  <div><span class="meta-label">ç¨®åˆ¥</span><span id="node-preview-type">-</span></div>
                  <div><span class="meta-label">ãƒ‘ã‚¹</span><code id="node-preview-path">-</code></div>
                  <div><span class="meta-label">ã‚µã‚¤ã‚º</span><span id="node-preview-size">-</span></div>
                </div>
                <div class="node-preview-body" id="node-preview-body">
                  <div class="preview-placeholder">ãƒãƒ¼ãƒ‰ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆã‚ã›ã‚‹ã¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚</div>
                </div>
              </div>
            </div>

            <div class="info-section" data-section="controls" hidden>
              <h3 class="info-heading">æ“ä½œæ–¹æ³•</h3>
              <ul>
                <li><strong>ãƒã‚¦ã‚¹</strong>
                  <ul>
                    <li>ãƒ‰ãƒ©ãƒƒã‚°: è¦–ç‚¹å¤‰æ›´</li>
                    <li>ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </li>
                    <li>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯: ãƒªã‚»ãƒƒãƒˆ</li>
                  </ul>
                </li>
                <li><strong>ãƒãƒ¼ãƒ‰</strong>
                  <ul>
                    <li>ã‚¯ãƒªãƒƒã‚¯: è©³ç´°è¡¨ç¤º</li>
                    <li>ãƒ‰ãƒ©ãƒƒã‚°: ç§»å‹•</li>
                    <li>ãƒ›ãƒãƒ¼: åå‰è¡¨ç¤º</li>
                  </ul>
                </li>
                <li><strong>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰</strong>
                  <ul>
                    <li>R: å†é…ç½®</li>
                    <li>C: ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ</li>
                    <li>F: å…¨ä½“ãƒ•ã‚£ãƒƒãƒˆ</li>
                  </ul>
                </li>
              </ul>
            </div>

            <div class="info-section" data-section="stats" hidden>
              <div class="directory-stats">
                <h3 class="info-heading">çµ±è¨ˆæƒ…å ±</h3>
                <div id="directory-stats-content">
                  <div class="stat-item">
                    <span class="stat-label">ãƒ•ã‚©ãƒ«ãƒ€æ•°:</span>
                    <span class="stat-value" id="folder-count">-</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">ãƒ•ã‚¡ã‚¤ãƒ«æ•°:</span>
                    <span class="stat-value" id="file-count">-</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">ç”»åƒ:</span>
                    <span class="stat-value" id="image-count">-</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">å‹•ç”»:</span>
                    <span class="stat-value" id="video-count">-</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">éŸ³å£°:</span>
                    <span class="stat-value" id="audio-count">-</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-label">HTML:</span>
                    <span class="stat-value" id="html-count">-</span>
                  </div>
                </div>
              </div>

              <div class="node-legend">
                <div class="legend-item">
                  <div class="legend-color" style="background: #ff6b6b;"></div>
                  <span class="legend-label">ãƒ«ãƒ¼ãƒˆ</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #4ecdc4;"></div>
                  <span class="legend-label">ãƒ•ã‚©ãƒ«ãƒ€</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #ffa502;"></div>
                  <span class="legend-label">ç”»åƒ</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #6c5ce7;"></div>
                  <span class="legend-label">å‹•ç”»</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #feca57;"></div>
                  <span class="legend-label">éŸ³å£°</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #dfe6e9;"></div>
                  <span class="legend-label">HTML</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <script type="module">
      // 3D Force GraphãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
      function initDirectoryGraph() {
        console.log('initDirectoryGraph called, ForceGraph3D:', typeof ForceGraph3D);
        if (typeof ForceGraph3D === 'undefined') {
          setTimeout(initDirectoryGraph, 100);
          return;
        }
        
        // å¯¾è±¡ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå¯è¦–ã«ãªã‚‹ã®ã‚’å¾…ã£ã¦ã‹ã‚‰åˆæœŸåŒ–
        const section = document.getElementById('directory-graph-3d');
        const canvasEl = document.getElementById('directory-graph-3d-canvas');
        const waitUntilVisible = () => {
          if (!section || !canvasEl) {
            setTimeout(waitUntilVisible, 200);
            return;
          }
          const visible = window.getComputedStyle(section).display !== 'none';
          const rect = canvasEl.getBoundingClientRect();
          if (visible && rect.width > 0 && rect.height > 0) {
            fetchDirectoryStructure().then(data => {
              if (data) createDirectoryGraph(data);
            });
          } else {
            setTimeout(waitUntilVisible, 200);
          }
        };
        waitUntilVisible();
      }
      
      // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ™ãƒ¼ã‚¹URLï¼ˆngrok/localhost/ãƒ—ãƒ­ã‚­ã‚·ï¼‰
      function getBackendBase() {
        const cleanup = (value) => {
          if (!value || typeof value !== 'string') return null;
          return value.trim().replace(/\/$/, '') || null;
        };

        const remember = (value) => {
          try {
            if (value) localStorage.setItem('kamuiBackend', value);
          } catch(_) {}
        };

        try {
          const params = new URLSearchParams(location.search);
          const q = cleanup(params.get('backend'));
          if (q) {
            remember(q);
            return q;
          }
        } catch(_) {}

        // Taskboard å´ã®æ°¸ç¶šåŒ–ãƒ‡ãƒ¼ã‚¿ã«ãƒ™ãƒ¼ã‚¹URLãŒã‚ã‚Œã°å„ªå…ˆ
        try {
          const raw = localStorage.getItem('kamui_task_board_v1');
          if (raw) {
            const parsed = JSON.parse(raw);
            const persisted = cleanup(parsed && parsed.backendBase);
            if (persisted) {
              remember(persisted);
              return persisted;
            }
          }
        } catch(_) {}

        try {
          const saved = cleanup(localStorage.getItem('kamuiBackend'));
          if (saved) return saved;
        } catch(_) {}

        if (typeof window !== 'undefined') {
          const globalBase = cleanup(window.KAMUI_BACKEND_BASE);
          if (globalBase) {
            remember(globalBase);
            return globalBase;
          }
        }

        if (typeof location !== 'undefined') {
          if (location.port === '1313') {
            const localBase = 'http://localhost:7777';
            remember(localBase);
            return localBase;
          }
          if (location.origin && location.origin !== 'null') {
            const proxied = cleanup(`${location.origin}/backend`);
            if (proxied) {
              remember(proxied);
              return proxied;
            }
          }
        }

        const fallback = 'http://localhost:7777';
        remember(fallback);
        return fallback;
      }
      const backendBase = getBackendBase();

      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’å–å¾—
      async function fetchDirectoryStructure() {
        try {
          // localhost:7777ã®ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å–å¾—
          const response = await fetch(`${backendBase}/api/scan`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const result = await response.json();
          console.log('API Response:', result);
          return result;
        } catch (error) {
          console.error('Error fetching directory structure:', error);
          document.querySelector('.loading-message').textContent = 
            'ã‚¨ãƒ©ãƒ¼: ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚backend/server.js ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
          return null;
        }
      }
      
      // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›
      function convertToGraphData(directoryData) {
        const nodes = [];
        const links = [];
        let nodeId = 0;
        const stats = {
          folders: 0,
          files: 0,
          images: 0,
          videos: 0,
          audio: 0,
          html: 0,
          yaml: 0,
          json: 0,
          code: 0,
          text: 0,
          doc: 0,
          other: 0
        };
        
        // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã‚’è¿½åŠ 
        const rootNode = {
          id: nodeId++,
          name: 'ROOT',
          type: 'root',
          path: directoryData.baseDir,
          group: 1
        };
        nodes.push(rootNode);
        
        // å†å¸°çš„ã«ãƒãƒ¼ãƒ‰ã¨ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
        function processDirectory(dirData, parentId, depth = 0) {
          // ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‡¦ç†
          if (dirData.folders) {
            dirData.folders.forEach(folder => {
              const folderId = nodeId++;
              const folderItems = folder.items || {};
              const childFolders = Array.isArray(folderItems.folders) ? folderItems.folders.map(child => child.name) : [];
              const childFiles = Array.isArray(folderItems.files) ? folderItems.files.map(child => child.name) : [];
              nodes.push({
                id: folderId,
                name: folder.name,
                type: 'folder',
                path: folder.path,
                group: 2,
                depth: depth,
                childFolders: childFolders.slice(0, 20),
                childFiles: childFiles.slice(0, 20),
                childFolderCount: childFolders.length,
                childFileCount: childFiles.length
              });
              links.push({
                source: parentId,
                target: folderId
              });
              stats.folders++;
              
              // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚’å†å¸°çš„ã«å‡¦ç†
              if (folder.items) {
                processDirectory(folder.items, folderId, depth + 1);
              }
            });
          }
          
          // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†
          if (dirData.files) {
            dirData.files.forEach(file => {
              const fileId = nodeId++;
              let group = 10; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ(ãã®ä»–)
              // ã‚µãƒ¼ãƒãƒ¼å´ã‚¿ã‚¤ãƒ—ãŒä¸æ˜ãªå ´åˆã¯æ‹¡å¼µå­ã‹ã‚‰è§£æ±º
              const ext = (file.ext || (file.name.split('.').pop() || '')).toLowerCase();
              let resolvedType = file.type;
              if (!resolvedType || resolvedType === 'other') {
                const isImage = ['jpg','jpeg','png','gif','webp','svg'].includes(ext);
                const isVideo = ['mp4','mov','avi','mkv','webm'].includes(ext);
                const isAudio = ['mp3','wav','ogg','flac','m4a'].includes(ext);
                const isHtml  = ['html','htm'].includes(ext);
                const isYaml  = ['yml','yaml'].includes(ext);
                const isJson  = ['json'].includes(ext);
                const isText  = ['txt','md','markdown','log'].includes(ext);
                const isCode  = ['js','ts','tsx','jsx','py','rb','go','rs','java','c','cc','cpp','h','hpp','cs','php','sh','bash','zsh','fish'].includes(ext);
                const isDoc   = ['pdf','doc','docx','ppt','pptx','xls','xlsx','csv','tsv'].includes(ext);
                resolvedType = isImage ? 'image'
                  : isVideo ? 'video'
                  : isAudio ? 'audio'
                  : isHtml  ? 'html'
                  : isYaml  ? 'yaml'
                  : isJson  ? 'json'
                  : isCode  ? 'code'
                  : isText  ? 'text'
                  : isDoc   ? 'doc'
                  : 'other';
              }

              switch(resolvedType) {
                case 'image':
                  group = 3; // ç”»åƒ
                  stats.images++;
                  break;
                case 'video':
                  group = 4; // å‹•ç”»
                  stats.videos++;
                  break;
                case 'audio':
                  group = 5; // éŸ³å£°
                  stats.audio++;
                  break;
                case 'html':
                  group = 6; // HTML
                  stats.html++;
                  break;
                case 'yaml':
                  group = 7; // YAML
                  stats.yaml++;
                  break;
                case 'json':
                  group = 8; // JSON
                  stats.json++;
                  break;
                case 'code':
                  group = 9; // ã‚³ãƒ¼ãƒ‰
                  stats.code++;
                  break;
                case 'text':
                  group = 11; // ãƒ†ã‚­ã‚¹ãƒˆ
                  stats.text++;
                  break;
                case 'doc':
                  group = 12; // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
                  stats.doc++;
                  break;
                default:
                  stats.other++;
              }
              
              nodes.push({
                id: fileId,
                name: file.name,
                type: resolvedType,
                path: file.path,
                size: file.size,
                group: group,
                depth: depth,
                ext: ext,
                rawType: file.type || resolvedType
              });
              links.push({
                source: parentId,
                target: fileId
              });
              stats.files++;
            });
          }
        }
        
        // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’å‡¦ç†
        processDirectory(directoryData.data, rootNode.id);
        
        console.log('Graph data:', { nodes: nodes.length, links: links.length, stats });
        return { nodes, links, stats };
      }
      
      // ã‚°ãƒ©ãƒ•ã‚’ä½œæˆ
      function createDirectoryGraph(directoryData) {
        const container = document.getElementById('directory-graph-3d-canvas');
        console.log('Container found:', container);
        if (!container) {
          console.error('Container not found');
          return;
        }
        
        // ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’ç¢ºèª
        const rect = container.getBoundingClientRect();
        console.log('Container size:', rect.width, 'x', rect.height);
        
        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
        container.innerHTML = '';
        
        const graphData = convertToGraphData(directoryData);
        
        // ãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆã®å‡¦ç†
        if (graphData.nodes.length === 0) {
          container.innerHTML = '<div class="loading-message">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
          return;
        }
        
        // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°ï¼ˆåŒä¸€ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã«ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
        const sectionRoot = container.closest('.doc-section') || document;
        const folderEl = sectionRoot.querySelector('#folder-count');
        const fileEl = sectionRoot.querySelector('#file-count');
        const imageEl = sectionRoot.querySelector('#image-count');
        const videoEl = sectionRoot.querySelector('#video-count');
        const audioEl = sectionRoot.querySelector('#audio-count');
        const htmlEl = sectionRoot.querySelector('#html-count');
        const yamlEl = sectionRoot.querySelector('#yaml-count');
        const jsonEl = sectionRoot.querySelector('#json-count');
        const codeEl = sectionRoot.querySelector('#code-count');
        const textEl = sectionRoot.querySelector('#text-count');
        const docEl = sectionRoot.querySelector('#doc-count');
        const otherEl = sectionRoot.querySelector('#other-count');
        if (folderEl) folderEl.textContent = graphData.stats.folders;
        if (fileEl) fileEl.textContent = graphData.stats.files;
        if (imageEl) imageEl.textContent = graphData.stats.images;
        if (videoEl) videoEl.textContent = graphData.stats.videos;
        if (audioEl) audioEl.textContent = graphData.stats.audio;
        if (htmlEl) htmlEl.textContent = graphData.stats.html;
        if (yamlEl) yamlEl.textContent = graphData.stats.yaml;
        if (jsonEl) jsonEl.textContent = graphData.stats.json;
        if (codeEl) codeEl.textContent = graphData.stats.code;
        if (textEl) textEl.textContent = graphData.stats.text;
        if (docEl) docEl.textContent = graphData.stats.doc;
        if (otherEl) otherEl.textContent = graphData.stats.other;

        const previewNameEl = sectionRoot.querySelector('#node-preview-name');
        const previewTypeEl = sectionRoot.querySelector('#node-preview-type');
        const previewPathEl = sectionRoot.querySelector('#node-preview-path');
        const previewSizeEl = sectionRoot.querySelector('#node-preview-size');
        const previewBodyEl = sectionRoot.querySelector('#node-preview-body');
        const infoButtons = sectionRoot ? Array.from(sectionRoot.querySelectorAll('.info-btn')) : [];
        const infoSections = sectionRoot ? Array.from(sectionRoot.querySelectorAll('.info-section')) : [];
        const setActiveInfoSection = (targetId) => {
          infoButtons.forEach(btn => {
            const isActive = btn.dataset.target === targetId;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
          infoSections.forEach(section => {
            const isActive = section.dataset.section === targetId;
            section.classList.toggle('active', isActive);
            section.hidden = !isActive;
          });
        };
        if (infoButtons.length && infoSections.length) {
          infoButtons.forEach(btn => {
            if (btn.dataset.bound === '1') return;
            btn.dataset.bound = '1';
            btn.addEventListener('click', (event) => {
              event.preventDefault();
              const target = btn.dataset.target;
              if (target) setActiveInfoSection(target);
            });
          });
          const initialTarget = infoButtons.find(btn => btn.classList.contains('active'))?.dataset.target
            || infoButtons[0]?.dataset.target;
          if (initialTarget) setActiveInfoSection(initialTarget);
        }
        const previewCache = new Map();
        let currentPreviewKey = null;
        let previewFetchToken = 0;
        const MAX_PREVIEW_LENGTH = 8000;
        const typeLabels = {
          root: 'ãƒ«ãƒ¼ãƒˆ',
          folder: 'ãƒ•ã‚©ãƒ«ãƒ€',
          image: 'ç”»åƒ',
          video: 'å‹•ç”»',
          audio: 'éŸ³å£°',
          html: 'HTML',
          yaml: 'YAML',
          json: 'JSON',
          code: 'ã‚³ãƒ¼ãƒ‰',
          text: 'ãƒ†ã‚­ã‚¹ãƒˆ',
          doc: 'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ',
          other: 'ãã®ä»–'
        };

        const baseDirectoryPath = directoryData.baseDir || '';

        function escapeHtml(str) {
          return String(str || '').replace(/[&<>"']/g, (ch) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch] || ch));
        }

        function formatBytes(bytes) {
          const size = Number(bytes);
          if (!Number.isFinite(size) || size < 0) return '-';
          if (size === 0) return '0 B';
          const units = ['B','KB','MB','GB','TB'];
          const idx = Math.min(units.length - 1, Math.floor(Math.log(size) / Math.log(1024)));
          const value = size / Math.pow(1024, idx);
          return `${value.toFixed(value >= 10 ? 0 : 1)} ${units[idx]}`;
        }

        function setPreviewMeta(node) {
          if (previewNameEl) previewNameEl.textContent = node?.name || '-';
          if (previewTypeEl) previewTypeEl.textContent = typeLabels[node?.type] || (node?.type || '-');
          const pathValue = node?.path || baseDirectoryPath || '-';
          if (previewPathEl) previewPathEl.textContent = pathValue;
          if (previewSizeEl) {
            if (!node || node.type === 'root') {
              previewSizeEl.textContent = '-';
            } else if (node.type === 'folder') {
              const folders = node.childFolderCount ?? 0;
              const files = node.childFileCount ?? 0;
              previewSizeEl.textContent = `${folders} ãƒ•ã‚©ãƒ«ãƒ€ / ${files} ãƒ•ã‚¡ã‚¤ãƒ«`;
            } else {
              previewSizeEl.textContent = formatBytes(node.size);
            }
          }
        }

        function setPreviewContent(html) {
          if (!previewBodyEl) return;
          previewBodyEl.innerHTML = html;
          previewBodyEl.scrollTop = 0;
        }

        function setPreviewPlaceholder(message) {
          setPreviewContent(`<div class="preview-placeholder">${escapeHtml(message)}</div>`);
        }

        function renderFolderPreview(node) {
          const folders = Array.isArray(node.childFolders) ? node.childFolders : [];
          const files = Array.isArray(node.childFiles) ? node.childFiles : [];
          const remainingFolders = Math.max(0, (node.childFolderCount || 0) - folders.length);
          const remainingFiles = Math.max(0, (node.childFileCount || 0) - files.length);
          const folderList = folders.length
            ? `<ul>${folders.map(name => `<li>ğŸ“ ${escapeHtml(name)}</li>`).join('')}</ul>${remainingFolders ? `<div class="preview-note">ä»– ${remainingFolders} ãƒ•ã‚©ãƒ«ãƒ€...</div>` : ''}`
            : '<div class="preview-note">ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
          const fileList = files.length
            ? `<ul>${files.map(name => `<li>ğŸ“„ ${escapeHtml(name)}</li>`).join('')}</ul>${remainingFiles ? `<div class="preview-note">ä»– ${remainingFiles} ãƒ•ã‚¡ã‚¤ãƒ«...</div>` : ''}`
            : '<div class="preview-note">ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
          setPreviewContent(`
            <div class="preview-section">
              <div class="preview-heading">ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€</div>
              ${folderList}
            </div>
            <div class="preview-section">
              <div class="preview-heading">ãƒ•ã‚¡ã‚¤ãƒ«</div>
              ${fileList}
            </div>
          `);
        }

        function renderRootPreview() {
          setPreviewContent(`<div class="preview-placeholder">ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: ${escapeHtml(baseDirectoryPath || 'ä¸æ˜')}</div>`);
        }

        function renderImagePreview(node) {
          const src = `${backendBase}/${encodeURI(node.path)}`;
          setPreviewContent(`
            <div class="preview-section">
              <img src="${src}" alt="${escapeHtml(node.name)}" loading="lazy" />
              <div class="preview-note">ç”»åƒã¯ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰çµŒç”±ã§å–å¾—ã—ã¾ã™ã€‚</div>
            </div>
          `);
        }

        function renderVideoPreview(node) {
          const src = `${backendBase}/${encodeURI(node.path)}`;
          setPreviewContent(`
            <div class="preview-section">
              <video controls preload="metadata" src="${src}"></video>
            </div>
          `);
        }

        function renderAudioPreview(node) {
          const src = `${backendBase}/${encodeURI(node.path)}`;
          setPreviewContent(`
            <div class="preview-section">
              <audio controls preload="metadata" src="${src}"></audio>
            </div>
          `);
        }

        function renderUnsupported(message) {
          setPreviewContent(`<div class="preview-placeholder">${escapeHtml(message || 'ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚')}</div>`);
        }

        function renderTextPreview(rawText, nodeType) {
          const text = String(rawText || '');
          const truncated = text.length > MAX_PREVIEW_LENGTH;
          const display = truncated ? `${text.slice(0, MAX_PREVIEW_LENGTH)}\nâ€¦(çœç•¥)` : text;
          const heading = nodeType === 'code'
            ? 'ã‚³ãƒ¼ãƒ‰'
            : nodeType === 'html'
            ? 'HTML'
            : nodeType === 'json'
            ? 'JSON'
            : nodeType === 'yaml'
            ? 'YAML'
            : 'ãƒ†ã‚­ã‚¹ãƒˆ';
          setPreviewContent(`
            <div class="preview-section">
              <div class="preview-heading">${heading}</div>
              <pre><code>${escapeHtml(display)}</code></pre>
              ${truncated ? '<div class="preview-note">â€» å…ˆé ­ã®ã¿è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚</div>' : ''}
            </div>
          `);
        }

        async function loadTextPreview(node) {
          const cacheKey = node.path;
          if (previewCache.has(cacheKey)) {
            const cached = previewCache.get(cacheKey);
            if (cached.kind === 'text') {
              renderTextPreview(cached.content, cached.type || node.type);
            }
            return;
          }
          const currentToken = ++previewFetchToken;
          setPreviewPlaceholder('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...');
          try {
            const res = await fetch(`${backendBase}/${encodeURI(node.path)}`, { cache: 'no-store' });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            let text = await res.text();
            if (node.type === 'json') {
              try {
                const parsed = JSON.parse(text);
                text = JSON.stringify(parsed, null, 2);
              } catch(_) {}
            }
            if (currentToken !== previewFetchToken) return;
            previewCache.set(cacheKey, { kind: 'text', content: text, type: node.type });
            renderTextPreview(text, node.type);
          } catch (err) {
            if (currentToken !== previewFetchToken) return;
            console.warn('Preview fetch failed:', err);
            renderUnsupported('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
          }
        }

        function showNodePreview(node, { force = false } = {}) {
          if (!node) return;
          const key = `${node.type || 'unknown'}:${node.path || node.id}`;
          if (!force && key === currentPreviewKey) return;
          currentPreviewKey = key;
          setPreviewMeta(node);
          if (!node.path && node.type !== 'root') {
            renderUnsupported('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã®ãƒ‘ã‚¹ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚');
            return;
          }
          switch (node.type) {
            case 'root':
              renderRootPreview();
              break;
            case 'folder':
              renderFolderPreview(node);
              break;
            case 'image':
              renderImagePreview(node);
              break;
            case 'video':
              renderVideoPreview(node);
              break;
            case 'audio':
              renderAudioPreview(node);
              break;
            case 'html':
            case 'yaml':
            case 'json':
            case 'code':
            case 'text':
              loadTextPreview(node);
              break;
            default:
              renderUnsupported();
          }
        }

        // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
        const colorPalette = {
          1: '#ff4757', // ãƒ«ãƒ¼ãƒˆ - å¼·ã„èµ¤
          2: '#2ed573', // ãƒ•ã‚©ãƒ«ãƒ€ - é®®ã‚„ã‹ãªã‚°ãƒªãƒ¼ãƒ³
          3: '#ffb84d', // ç”»åƒ - è–„ã„ã‚ªãƒ¬ãƒ³ã‚¸
          4: '#6c5ce7', // å‹•ç”» - ãƒ‘ãƒ¼ãƒ—ãƒ«
          5: '#eccc68', // éŸ³å£° - æ¸©ã‹ã„ã‚¤ã‚¨ãƒ­ãƒ¼
          6: '#a4b0be', // HTML - ã‚°ãƒ¬ãƒ¼
          7: '#6c5ce7', // YAML - ãƒ‘ãƒ¼ãƒ—ãƒ«ï¼ˆå‹•ç”»ã¨åŒç³»è‰²ã ãŒåˆ¥ç”¨é€”ï¼‰
          8: '#00d2d3', // JSON - ãƒ†ã‚£ãƒ¼ãƒ«
          9: '#ff6b81', // ã‚³ãƒ¼ãƒ‰ - ãƒ”ãƒ³ã‚¯ãƒ¬ãƒƒãƒ‰
          10:'#57606f', // ãã®ä»– - ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼
          11:'#70a1ff', // ãƒ†ã‚­ã‚¹ãƒˆ - ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼
          12:'#2f3542'  // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ - ãƒ€ãƒ¼ã‚¯
        };
        
        console.log('Creating graph with container:', container);
        const Graph = ForceGraph3D()(container)
          .backgroundColor('#000003')
          .graphData(graphData)
          .nodeLabel(node => `${node.name}\n${node.type === 'folder' ? 'ãƒ•ã‚©ãƒ«ãƒ€' : node.type}`)
          .nodeColor(node => colorPalette[node.group] || '#ffffff')
          .nodeOpacity(0.9)
          .nodeResolution(16)
          .nodeVal(node => {
            // ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã‚’ç¨®é¡ã«å¿œã˜ã¦è¨­å®š
            if (node.type === 'root') return 30;
            if (node.type === 'folder') return 15;
            if (node.type === 'video') return 10;
            if (node.type === 'image') return 8;
            return 6;
          })
          .linkOpacity(0.75)
          .linkWidth(4)
          .linkColor(() => 'rgba(255,255,255,0.5)')
          .linkDirectionalParticles(2)
          .linkDirectionalParticleWidth(3)
          .linkDirectionalParticleSpeed(0.01)
          .enableNodeDrag(true)
          .enableNavigationControls(true)
          .showNavInfo(false)
          .d3VelocityDecay(0.3)
          .d3AlphaDecay(0.02)
          .dagMode(null);
        // å€‹åˆ¥é©ç”¨ï¼ˆã‚¨ãƒ©ãƒ¼å›é¿ï¼‰
        try {
          Graph.d3Force('charge').strength(-300);
          Graph.d3Force('link').distance(80);
        } catch (e) {
          console.warn('d3Force setup skipped:', e);
        }
        const finalizedGraph = Graph
          .warmupTicks(100)
          .cooldownTicks(0)
          .onNodeClick(node => {
            if (!node) return;
            console.log('Node clicked:', node);
            showNodePreview(node, { force: true });
            // ãƒãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
            const distance = 40;
            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
            Graph.cameraPosition(
              { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
              node,
              3000
            );
          })
          .onNodeHover(node => {
            container.style.cursor = node ? 'pointer' : null;
            if (node) showNodePreview(node);
          })
          .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;
          });

        // WebXR AR å¯¾å¿œï¼ˆARButtonèª­ã¿è¾¼ã¿å¾…ã¡ã«ã‚‚å¯¾å¿œï¼‰
        try {
          const renderer = Graph.renderer && Graph.renderer();
          const scene = Graph.scene && Graph.scene();
          const mountEl = (sectionRoot && sectionRoot.querySelector && sectionRoot.querySelector('.view-toggle')) || container;
          function trySetupAR(times = 20) {
            try {
              if (!renderer || !scene) return; // GraphæœªåˆæœŸåŒ–
              const ARLib = window.ARButton || (window.THREE && window.THREE.ARButton);
              if (!navigator.xr || !ARLib) {
                if (times > 0) setTimeout(() => trySetupAR(times - 1), 300);
                return;
              }
              renderer.xr.enabled = true;
              try { renderer.xr.setReferenceSpaceType && renderer.xr.setReferenceSpaceType('local'); } catch(_){ }
              // é€æ˜èƒŒæ™¯ã§å®Ÿå†™åˆæˆ
              try { renderer.setClearAlpha(0); renderer.domElement.style.background = 'transparent'; } catch(_) {}
              const arBtn = ARLib.createButton(renderer, { requiredFeatures: ['local'], optionalFeatures: ['hit-test'] });
              arBtn.style.marginLeft = 'auto';
              if (mountEl && !mountEl.querySelector('.ar-button')) {
                // threeã®ARButtonã¯className='ar-button'ã‚’æŒã¤
                mountEl.appendChild(arBtn);
              }
              let arGroup = null;
              renderer.xr.addEventListener('sessionstart', () => {
                try {
                  if (!arGroup) {
                    arGroup = new THREE.Group();
                    arGroup.name = 'graphArGroup';
                    const toMove = scene.children.filter(obj => !obj.isLight);
                    toMove.forEach(obj => { scene.remove(obj); arGroup.add(obj); });
                    scene.add(arGroup);
                  }
                  // è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»é…ç½®
                  arGroup.updateMatrixWorld(true);
                  const box = new THREE.Box3().setFromObject(arGroup);
                  const size = new THREE.Vector3(); box.getSize(size);
                  const center = new THREE.Vector3(); box.getCenter(center);
                  const maxDim = Math.max(size.x, size.y, size.z) || 1;
                  const target = 1.2; // ç´„1.2mã«åã‚ã‚‹
                  const s = target / maxDim;
                  arGroup.scale.setScalar(s);
                  arGroup.position.sub(center);
                  arGroup.position.z -= 1.5;
                  arGroup.position.y -= 0.2;
                  // XRæç”»ãƒ«ãƒ¼ãƒ—
                  const cam = (Graph.camera && Graph.camera()) || null;
                  if (renderer.setAnimationLoop && cam) {
                    renderer.setAnimationLoop(() => {
                      try { renderer.render(scene, cam); } catch(_) {}
                    });
                  }
                } catch(e) { console.warn('AR group setup failed:', e); }
              });
              renderer.xr.addEventListener('sessionend', () => {
                try {
                  if (arGroup) {
                    const toMoveBack = [...arGroup.children];
                    toMoveBack.forEach(obj => { arGroup.remove(obj); scene.add(obj); });
                    scene.remove(arGroup);
                    arGroup = null;
                  }
                  if (renderer.setAnimationLoop) renderer.setAnimationLoop(null);
                } catch(e) { console.warn('AR teardown failed:', e); }
              });
            } catch(e) { console.warn('AR setup error:', e); }
          }
          trySetupAR();

          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ARButtonæœªèª­è¾¼ã§ã‚‚ç‹¬è‡ªARãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
          async function ensureCustomARButton() {
            try {
              if (!renderer || !scene || !navigator.xr) return;
              if (mountEl.querySelector('.ar-button')) return; // æ—¢ã«ARãƒœã‚¿ãƒ³ã‚ã‚Š
              const supported = await navigator.xr.isSessionSupported('immersive-ar');
              if (!supported) return;
              const btn = document.createElement('button');
              btn.textContent = 'Enter AR';
              btn.className = 'toggle-btn ar-button';
              btn.style.marginLeft = 'auto';
              btn.addEventListener('click', async () => {
                try {
                  renderer.xr.enabled = true;
                  const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor']
                  });
                  await renderer.xr.setSession(session);
                } catch(err) { console.warn('XR session failed:', err); }
              });
              mountEl.appendChild(btn);
            } catch(err) { console.warn('ensureCustomARButton failed:', err); }
          }
          setTimeout(ensureCustomARButton, 1200);
        } catch(e) { console.warn('AR setup skipped:', e); }
        
        // è»½é‡ãªã‚°ãƒ­ãƒ¼: ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã‚’ä¸Šã’ã¦ä»£æ›¿çš„ã«ã€Œå…‰ã‚‰ã›ã‚‹ã€è¡¨ç¾
        // Threeã®å¤šé‡ãƒ­ãƒ¼ãƒ‰å›é¿ã®ãŸã‚postprocessingã¯ä½¿ã‚ãšè¦–è¦šçš„ã«å¼·èª¿
        
        // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ãƒªã‚»ãƒƒãƒˆ
        container.addEventListener('dblclick', () => {
          Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
        });
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼ˆã“ã®ã‚°ãƒ©ãƒ•ãŒãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
        let keyHandler = (event) => {
          // ã‚³ãƒ³ãƒ†ãƒŠã¾ãŸã¯ãã®å­è¦ç´ ãŒãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          if (!container.contains(document.activeElement) && document.activeElement !== document.body) {
            return;
          }
          
          if (event.key === 'r' || event.key === 'R') {
            // Rã‚­ãƒ¼ã§å†é…ç½®
            Graph.d3ReheatSimulation();
          } else if (event.key === 'c' || event.key === 'C') {
            // Cã‚­ãƒ¼ã§ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ
            Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
          } else if (event.key === 'f' || event.key === 'F') {
            // Fã‚­ãƒ¼ã§ãƒ•ã‚£ãƒƒãƒˆ
            Graph.zoomToFit(1000, 100);
          }
        };
        
        // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã«ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ–
        container.addEventListener('click', () => {
          container.tabIndex = -1;
          container.focus();
        });
        
        document.addEventListener('keydown', keyHandler);
        
        // åˆæœŸã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨­å®šï¼ˆã‚ˆã‚Šé ãã‹ã‚‰å…¨ä½“ã‚’è¦‹æ¸¡ã›ã‚‹ã‚ˆã†ã«ï¼‰
        Graph.cameraPosition({ x: 0, y: 0, z: 1000 });
        
        // åˆæœŸè¡¨ç¤ºæ™‚ã«å…¨ä½“ã‚’ãƒ•ã‚£ãƒƒãƒˆ
        setTimeout(() => {
          console.log('Graph created, checking container:', container.getBoundingClientRect());
          console.log('Graph scene:', Graph.scene());
          console.log('Graph camera:', Graph.camera());
          Graph.zoomToFit(1000, 100);
        }, 500);
        
        // ã‚°ãƒ©ãƒ•ä½œæˆå®Œäº†ãƒ­ã‚°
        console.log('Directory graph creation completed');
        
        // å®šæœŸçš„ã«ã‚³ãƒ³ãƒ†ãƒŠã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        setTimeout(() => {
          const rect = container.getBoundingClientRect();
          console.log('Container after 2s:', rect.width, 'x', rect.height);
          console.log('Container display:', window.getComputedStyle(container).display);
          console.log('Container visibility:', window.getComputedStyle(container).visibility);
          console.log('Container children:', container.children.length);
          console.log('Canvas found:', container.querySelector('canvas'));
        }, 2000);
        // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        const colorBtn = document.getElementById('toggle-color-mode');
        const mediaBtn = document.getElementById('toggle-media-mode');
        let showMediaTexture = true;
        const applyActive = () => {
          if (colorBtn) colorBtn.classList.toggle('active', !showMediaTexture);
          if (mediaBtn) mediaBtn.classList.toggle('active', showMediaTexture);
        };
        
        // ç”»åƒ/å‹•ç”»ãƒãƒ¼ãƒ‰ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£é©ç”¨
        const loader = new Image();
        const getVideoThumbUrl = (path) => `${backendBase}/${encodeURI(path)}`; // ã²ã¨ã¾ãšåŒURLã‚’ä½¿ç”¨ï¼ˆå°†æ¥ã‚µãƒ ãƒAPIã«ï¼‰
        
        const textureCache = new Map();
        function setMediaTextures(enabled) {
          showMediaTexture = enabled;
          applyActive();
          Graph.nodeThreeObject(node => {
            if (!enabled) return undefined; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæç”»
            if (node.type !== 'image' && node.type !== 'video') return undefined;
            const key = `${node.type}:${node.path}`;
            if (!textureCache.has(key)) {
              const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0xffffff }));
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => {
                const tex = new THREE.Texture(img);
                tex.needsUpdate = true;
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
              };
              img.src = node.type === 'image' ? `${backendBase}/${encodeURI(node.path)}` : getVideoThumbUrl(node.path);
              sprite.scale.set(16, 12, 1);
              textureCache.set(key, sprite);
            }
            return textureCache.get(key);
          });
          // å†æç”»
          Graph.refresh();
        }
        if (showMediaTexture) {
          setMediaTextures(true);
        } else {
          applyActive();
        }
        mediaBtn?.addEventListener('click', () => setMediaTextures(true));
        colorBtn?.addEventListener('click', () => setMediaTextures(false));
      }
      
      // åˆæœŸåŒ–é–‹å§‹ï¼ˆãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œï¼‰
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDirectoryGraph);
      } else {
        // æ—¢ã«èª­ã¿è¾¼ã¿å®Œäº†ã—ã¦ã„ã‚‹å ´åˆ
        setTimeout(initDirectoryGraph, 100);
      }
    </script>
